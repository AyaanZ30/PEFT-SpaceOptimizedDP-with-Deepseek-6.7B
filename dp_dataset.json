[
    {
        "problem_name": "01 Knapsack",
        "naive_code": "int recursion_approach(int idx, int maxWeight, vector<int> &weights, vector<int> &values){\n    if(idx == 0){\n        return ((weights[idx] <= maxWeight) ? values[idx] : 0);\n    }\n    int not_take = 0 + recursion_approach(idx-1, maxWeight, weights, values);\n    int take = INT_MIN;\n    if(weights[idx] <= maxWeight){\n        take = values[idx] + recursion_approach(idx-1, maxWeight - weights[idx], weights, values);\n    }\n    cout << \"Time Complexity: O(2^n)\" << endl;\n    cout << \"Space Complexity: O(n)  (recursion stack space)\" << endl;\n    return max(take, not_take);\n}",
        "optimized_code": "int hyper_optimized_approach(vector<int> &weights, vector<int> &values, int n, int maxWeight){\n    vector<int> prev(maxWeight + 1, 0);\n    for(int w = weights[0] ; w <= maxWeight ; w++){\n        prev[w] = values[0];\n    }\n    for(int idx = 1 ; idx < n ; idx++){\n        for(int w = maxWeight ; w >= 0 ; w--){\n            int notTake = 0 + prev[w];\n            int take = INT_MIN;\n            if(weights[idx] <= w){\n                take = values[idx] + prev[w - weights[idx]];\n            }\n            prev[w] = max(take, notTake);\n        }\n    }\n    return prev[maxWeight];\n}",
        "naive_explanation": "No explanation provided",
        "optimized_explanation": "Space-optimized 1D DP",
        "naive_complexity": "No complexity provided",
        "optimized_complexity": "Time: O(n * maxWeight), Space: O(maxWeight)."
    },
    {
        "problem_name": "Bool Eval T",
        "naive_code": "(TC : O(exponential) SC : O(n) auxiliary stack space)\nint recursion_approach(int i, int j, int isTrue, const vector<char> &arr){\n    // base cases\n    if(i > j && isTrue == 0){         // if partitions are over\n        return 0;\n    }\n    if(i == j){\n        if(isTrue == 1){\n            return (arr[i] == 'T') ? 1 : 0;\n        }else{\n            return (arr[i] == 'F') ? 1 : 0;\n        }\n    }\n    int total_ways = 0;\n    // main logic (since 'T^F&T|T' has both operators at alternate idx (last being j-1), we iterate over operators only as problem can be partitioned at that index only)\n    for(int operator_idx = i+1 ; operator_idx <= j-1 ; operator_idx += 2){\n        int leftTrue = recursion_approach(i, operator_idx - 1, 1, arr);    // no of ways left partition can be true\n        int leftFalse = recursion_approach(i, operator_idx - 1, 0, arr);    // no of ways left partition can be false\n        int rightTrue = recursion_approach(operator_idx + 1, j, 1, arr);    // no of ways right partition can be true\n        int rightFalse = recursion_approach(operator_idx + 1, j, 0, arr);   // no of ways right partition can be false\n\n        if(arr[operator_idx] == '&'){\n            total_ways += (isTrue == 1) ? ((leftTrue * rightTrue)) : ((leftTrue * rightFalse) + (leftFalse * rightTrue) + (leftFalse * rightFalse));     // for AND : (only T & T = T)\n        }else if(arr[operator_idx] == '|'){\n            total_ways += (isTrue == 1) ? ((leftTrue * rightTrue) + (leftTrue * rightFalse) + (leftFalse * rightTrue)) : ((leftFalse * rightFalse));   // for OR : (T | T = T), (T | F = T), (F | T = T)\n        }else{\n            total_ways += (isTrue == 1) ? ((leftTrue * rightFalse) + (leftFalse * rightTrue)) : ((leftTrue * rightTrue) + (leftFalse * rightFalse));   // for XOR : (T ^ F = T), (F ^ T = T)\n        }\n    }\n    return total_ways;\n}",
        "optimized_code": "// (BOTTOM-UP approach)\nint hyper_optimized_approach(const vector<char> &arr){\n    int n = arr.size();\n    vector<vector<vector<int>>> dp(n, vector<vector<int>>(n, vector<int>(2, 0)));\n\n    // base cases analogy (check recursion)\n    for(int i = 0 ; i < n ; i += 2){\n        dp[i][i][1] = (arr[i] == 'T') ? 1 : 0;\n        dp[i][i][0] = (arr[i] == 'F') ? 1 : 0;\n    }\n    // main logic (always loop in oppposite fashion as compared to recursion as bottom up)\n    for(int i = n - 1 ; i >= 0 ; i -= 2){       // i moves only on operands\n        for(int j = i + 2 ; j < n ; j += 2){   // j moves only on operands\n            for(int isTrue = 0 ; isTrue <= 1 ; isTrue++){\n                if(i > j){continue;}\n                int total_ways = 0;\n\n                for(int operator_idx = i + 1 ; operator_idx <= j - 1 ; operator_idx += 2){\n                    int leftTrue = dp[i][operator_idx - 1][1];    // no of ways left partition can be true\n                    int leftFalse = dp[i][operator_idx - 1][0];   // no of ways left partition can be false\n                    int rightTrue = dp[operator_idx + 1][j][1];   // no of ways right partition can be true\n                    int rightFalse = dp[operator_idx + 1][j][0];  // no of ways right partition can be false\n\n                    if(arr[operator_idx] == '&'){\n                        total_ways += (isTrue == 1) ? ((leftTrue * rightTrue)) : ((leftTrue * rightFalse) + (leftFalse * rightTrue) + (leftFalse * rightFalse));     // for AND : (only T & T = T)\n                    }else if(arr[operator_idx] == '|'){\n                        total_ways += (isTrue == 1) ? ((leftTrue * rightTrue) + (leftTrue * rightFalse) + (leftFalse * rightTrue)) : ((leftFalse * rightFalse));   // for OR : (T | T = T), (T | F = T), (F | T = T)\n                    }else{\n                        total_ways += (isTrue == 1) ? ((leftTrue * rightFalse) + (leftFalse * rightTrue)) : ((leftTrue * rightTrue) + (leftFalse * rightFalse));   // for XOR : (T ^ F = T), (F ^ T = T)\n                    }\n                }\n                dp[i][j][isTrue] = total_ways;\n            }\n        }\n    }\n    return dp[0][n-1][1];\n}",
        "naive_explanation": "No explanation provided",
        "optimized_explanation": "Space-optimized 3D DP",
        "naive_complexity": "No complexity provided",
        "optimized_complexity": "No complexity provided"
    },
    {
        "problem_name": "Burst Balloons",
        "naive_code": "(TC : O(exponential) SC : O(n) auxiliary stack space)\nint recursion_approach(int i, int j, const vector<int> &cost){\n    if(i > j){\n        return 0;\n    }\n    int maxi = -1e9;\n    // core logic (starting from bursting a single balloon and working upwards by recursively solving independent subproblems)\n    for(int idx = i ; idx <= j ; idx++){\n        int coins = (cost[i-1] * cost[idx] * cost[j+1]) + \n        recursion_approach(i, idx-1, cost) + recursion_approach(idx+1, j, cost);\n        maxi = max(maxi, coins);\n    }\n    return maxi;\n}",
        "optimized_code": "// (BOTTOM-UP approach) (TC : O(n^3) SC : O(n^2) for DP table)\nint hyper_optimized_approach(const vector<int> &costs){\n    int n = costs.size();\n    vector<vector<int>> dp(n+2 ,vector<int>(n+2, 0));\n\n    // main logic (always loop in oppposite fashion as compared to recursion as bottom up)\n    for(int i = n ; i >= 1 ; i--){\n        for(int j = 1 ; j <= n ; j++){\n            if(i > j){continue;}\n            int maxi = -1e9;\n\n            for(int idx = i ; idx <= j ; idx++){\n                int cost = (costs[i-1] * costs[idx] * costs[j+1]) + dp[i][idx-1] + dp[idx+1][j];\n                maxi = max(maxi, cost);\n            }\n            dp[i][j] = maxi;\n        }\n    }\n    return dp[1][n];\n}",
        "naive_explanation": "No explanation provided",
        "optimized_explanation": "Space-optimized 2D DP",
        "naive_complexity": "No complexity provided",
        "optimized_complexity": "No complexity provided"
    },
    {
        "problem_name": "Buy Sell Cooldown",
        "naive_code": "int recursion_approach(int idx, int buy, const vector<int> &prices){\n    long maxProfit = 0;\n    // base case\n    if(idx >= prices.size()){\n        return 0;\n    }\n    // if buy(=1) you still have librety to buy (can/cannot), else you have to sell the stock you previously bought first before buying another\n    if(buy){ \n        maxProfit =  max(-prices[idx] + recursion_approach(idx+1, 0, prices), \n                        0 + recursion_approach(idx+1, 1, prices));\n    }else{\n        maxProfit = max(prices[idx] + recursion_approach(idx+2, 1, prices), \n                        0 + recursion_approach(idx+1, 0, prices));\n    }\n    return maxProfit;\n    cout << \"\\nTC : O(2^N)\" << endl;\n    cout << \"SC : O(N) (auxiliary stack)\" << endl;\n}\n\nint tabulation_approach(const vector<int> &prices){\n    int n = prices.size();\n    vector<vector<int>> dp(n+2, vector<int>(2, 0));\n\n    // analogous to recursion base cases (idx == n)\n    dp[n][0] = dp[n][1] = 0;\n    for(int idx = n-1 ; idx >= 0 ; idx--){\n        for(int buy = 0 ; buy <= 1 ; buy++){    // buy(1) or not buy(0)\n            if(buy){\n                dp[idx][buy] = max(-prices[idx] + dp[idx+1][0], 0 + dp[idx+1][1]);\n            }else{\n                dp[idx][buy] = max(prices[idx] + dp[idx+2][1], 0 + dp[idx+1][0]);\n            }\n        }\n    }\n    return dp[0][1];    \n}",
        "optimized_code": "int hyper_optimized_approach(const vector<int> &prices){    // convert s1 -> s2 \n    int n = prices.size();\n    vector<vector<int>> dp(n+2, vector<int>(2, 0));\n\n    // analogous to recursion base cases (idx == n)\n    dp[n][0] = dp[n][1] = 0;\n    for(int idx = n-1 ; idx >= 0 ; idx--){\n        // buy(1) or not buy(0)\n        dp[idx][1] = max(-prices[idx] + dp[idx+1][0], 0 + dp[idx+1][1]);\n        dp[idx][0] = max(prices[idx] + dp[idx+2][1], 0 + dp[idx+1][0]);\n    }\n    return dp[0][1];\n}",
        "naive_explanation": "No explanation provided",
        "optimized_explanation": "Space-optimized 2D DP",
        "naive_complexity": "No complexity provided",
        "optimized_complexity": "Time: O(N) , Space:  O(N*2)"
    },
    {
        "problem_name": "Buy Sell Fee",
        "naive_code": "int recursion_approach(int idx, int buy, int fee, const vector<int> &prices){\n    long maxProfit = 0;\n    // base case\n    if(idx >= prices.size()){\n        return 0;\n    }\n    // if buy(=1) you still have librety to buy (can/cannot), else you have to sell the stock you previously bought first before buying another\n    if(buy){ \n        maxProfit =  max(-prices[idx] + recursion_approach(idx+1, 0, fee, prices), \n                        0 + recursion_approach(idx+1, 1, fee, prices));\n    }else{\n        // everytime you sell (finish a transaction), you have to pay a fee\n        maxProfit = max((prices[idx] - fee) + recursion_approach(idx+1, 1, fee, prices), \n                        0 + recursion_approach(idx+1, 0, fee, prices));\n    }\n    return maxProfit;\n    cout << \"\\nTC : O(2^N)\" << endl;\n    cout << \"SC : O(N) (auxiliary stack)\" << endl;\n}\n\nint tabulation_approach(const vector<int> &prices, int fee){\n    int n = prices.size();\n    vector<vector<int>> dp(n+2, vector<int>(2, 0));\n\n    // analogous to recursion base cases (idx == n)\n    dp[n][0] = dp[n][1] = 0;\n    for(int idx = n-1 ; idx >= 0 ; idx--){\n        for(int buy = 0 ; buy <= 1 ; buy++){    // buy(1) or not buy(0)\n            if(buy){\n                dp[idx][buy] = max(-prices[idx] + dp[idx+1][0], 0 + dp[idx+1][1]);\n            }else{\n                dp[idx][buy] = max(((prices[idx] - fee) + dp[idx+2][1]), 0 + dp[idx+1][0]);\n            }\n        }\n    }\n    return dp[0][1];    \n}",
        "optimized_code": "int hyper_optimized_approach(const vector<int> &prices, int fee){    // convert s1 -> s2 \n    int n = prices.size();\n    vector<vector<int>> dp(n+2, vector<int>(2, 0));\n\n    // analogous to recursion base cases (idx == n)\n    dp[n][0] = dp[n][1] = 0;\n    for(int idx = n-1 ; idx >= 0 ; idx--){\n        // buy(1) or not buy(0)\n        dp[idx][1] = max(-prices[idx] + dp[idx+1][0], 0 + dp[idx+1][1]);\n        dp[idx][0] = max((prices[idx] - fee) + dp[idx+2][1], 0 + dp[idx+1][0]);\n    }\n    return dp[0][1];\n}",
        "naive_explanation": "No explanation provided",
        "optimized_explanation": "Space-optimized 2D DP",
        "naive_complexity": "No complexity provided",
        "optimized_complexity": "Time: O(N) , Space:  O(N*2)"
    },
    {
        "problem_name": "Buy Sell Stock 1",
        "naive_code": "",
        "optimized_code": "int hyper_optimized_approach(const vector<int> &prices){    // convert s1 -> s2 \n    int maxProfit = 0;\n    int mini = prices[0];\n\n    for(int i = 0 ; i < prices.size() ; i++){\n        int current_profit = (prices[i] - mini);\n        maxProfit = max(current_profit, maxProfit);\n        mini = min(prices[i], mini);\n    }\n    return maxProfit;\n}",
        "naive_explanation": "No explanation provided",
        "optimized_explanation": "Space-optimized 1D DP",
        "naive_complexity": "No complexity provided",
        "optimized_complexity": "Time: O(N) , Space:  O(1)"
    },
    {
        "problem_name": "Buy Sell Stock 2",
        "naive_code": "int recursion_approach(int idx, int buy, const vector<int> &prices){\n    long maxProfit = 0;\n    // base case\n    if(idx == prices.size()){\n        return 0;\n    }\n    // if buy(=1) you still have librety to buy (can/cannot), else you have to sell the stock you previously bought first before buying another\n    if(buy){\n        int ahead_not_buy = recursion_approach(idx+1, 0, prices);  \n        int ahead_buy = recursion_approach(idx+1, 1, prices);  \n        maxProfit =  max(-prices[idx] + ahead_not_buy, 0 + ahead_buy);\n    }else{\n        int ahead_can_buy = recursion_approach(idx+1, 1, prices);    // only if you have sold prev, you can buy next\n        int ahead_must_sell = recursion_approach(idx+1, 0, prices);    // you cannot buy next without selling prev\n        maxProfit = max(prices[idx] + ahead_can_buy, 0 + ahead_must_sell);\n    }\n    cout << \"TC : O(2^N)\" << endl;\n    cout << \"SC : O(N) (auxiliary stack)\" << endl;\n    return maxProfit;\n}\n\nint tabulation_approach(const vector<int> &prices){\n    int n = prices.size();\n    vector<vector<int>> dp(n+1, vector<int>(2, 0));\n\n    // analogous to recursion base cases (idx == n)\n    dp[n][0] = dp[n][1] = 0;\n    for(int idx = n-1 ; idx >= 0 ; idx--){\n        for(int buy = 0 ; buy <= 1 ; buy++){    // buy(1) or not buy(0)\n            if(buy){\n                dp[idx][buy] = max(-prices[idx] + dp[idx+1][0], 0 + dp[idx+1][1]);\n            }else{\n                dp[idx][buy] = max(prices[idx] + dp[idx+1][1], 0 + dp[idx+1][0]);\n            }\n        }\n    }\n    return dp[0][1];    \n}",
        "optimized_code": "int hyper_optimized_approach(const vector<int> &prices){    // convert s1 -> s2 \n    int n = prices.size();\n    vector<int> ahead(2, 0), curr(2, 0); // since for computing current state (idx) we only ahead values (idx+1) (refer tabulation logic)\n\n    ahead[0] = ahead[1] = 0;\n    for(int idx = n-1 ; idx >= 0 ; idx--){\n        for(int buy = 0 ; buy <= 1 ; buy++){    // buy(1) or not buy(0)\n            if(buy){\n                curr[buy] = max(-prices[idx] + ahead[0], 0 + ahead[1]);\n            }else{\n                curr[buy] = max(prices[idx] + ahead[1], 0 + ahead[0]);\n            }\n        }\n        ahead = curr;\n    }\n    return ahead[1];\n}",
        "naive_explanation": "No explanation provided",
        "optimized_explanation": "Space-optimized 1D DP",
        "naive_complexity": "No complexity provided",
        "optimized_complexity": "Time: O(N) , Space:  O(1)"
    },
    {
        "problem_name": "Buy Sell Stock 3",
        "naive_code": "int recursion_approach(int idx, int buy, int capacity, const vector<int> &prices){\n    long maxProfit = 0;\n    // base case\n    if(capacity == 0 || idx == prices.size()){\n        return 0;\n    }\n    // if buy(=1) you still have librety to buy (can/cannot), else you have to sell the stock you previously bought first before buying another\n    if(buy){\n        int ahead_not_buy = recursion_approach(idx+1, 0, capacity, prices);  \n        int ahead_buy = recursion_approach(idx+1, 1, capacity, prices);  \n        maxProfit =  max(-prices[idx] + ahead_not_buy, 0 + ahead_buy);\n    }else{\n        int ahead_can_buy = recursion_approach(idx+1, 1, capacity-1, prices);    // if prev bought stock is sold (which means one full transaction is completed) -> reduce the capacity by 1 (as max 2 transacitons allowed)\n        int ahead_must_sell = recursion_approach(idx+1, 0, capacity, prices);    // you cannot buy next without selling prev\n        maxProfit = max(prices[idx] + ahead_can_buy, 0 + ahead_must_sell);\n    }\n    cout << \"TC : O(2^N)\" << endl;\n    cout << \"SC : O(N) (auxiliary stack)\" << endl;\n    return maxProfit;\n}\n\nint tabulation_approach(const vector<int> &prices, int capacity){\n    int n = prices.size();\n    int buy_options = 2;      // either 0/1 (not buy/buy)\n\n    // since limited no of transactions(B+S) are 2 (can be 0, 1, 2) we will have a 3D DP(as there are 3 changing params(idx, buy, capacity))\n    // declare 3d dp based on 3 changing params dp[n+1][2(0/1)][3(0/1/2)]\n    vector<vector<vector<int>>> dp(n+1, vector<vector<int>>(buy_options, vector<int>(3, 0)));\n\n    // 1st base case (when capacity = 0) (analogous to recusive base case)\n    for(int idx = 0 ; idx < n ; idx++){\n        for(int buy = 0 ; buy < buy_options ; buy++){\n            dp[idx][buy][0] = 0;                 \n        }\n    }\n    // 2nd base case (when idx = n)  (analogous to recusive base case)\n    for(int buy = 0 ; buy < buy_options ; buy++){\n        for(int cap = 0 ; cap < capacity ; cap++){\n            dp[n][buy][cap] = 0;\n        }\n    }\n\n    // core logic\n    for(int idx = n-1 ; idx >= 0 ; idx--){\n        for(int buy = 0 ; buy < buy_options ; buy++){\n            for(int cap = 1 ; cap <= capacity ; cap++){\n                if(buy){\n                    int ahead_sell = dp[idx+1][0][cap];   // if decided to buy\n                    int ahead_buy = dp[idx+1][1][cap];    // if decided to not buy (and look ahead)\n                    dp[idx][buy][cap] = max(-prices[idx] + ahead_sell, 0 + ahead_buy);\n                }else{\n                    int ahead_can_buy = dp[idx+1][1][cap-1];\n                    int ahead_must_sell = dp[idx+1][0][cap]; \n                    dp[idx][buy][cap] = max(prices[idx] + ahead_can_buy, 0 + ahead_must_sell);\n                }\n            }\n        }\n    }\n    cout << \"\\nTC : O(N*2*3)\" << endl;\n    cout << \"SC : O(N*2*3) (no auxiliary stack by avoiding recursion)\" << endl;\n    return dp[0][1][2];\n}",
        "optimized_code": "int hyper_optimized_approach(const vector<int> &prices, int capacity){    // convert s1 -> s2 \n    int n = prices.size();\n    int buy_options = 2;      \n\n    vector<vector<int>> after(buy_options, vector<int>(3, 0));\n    vector<vector<int>> curr(buy_options, vector<int>(3, 0));\n\n    // core logic\n    for(int idx = n-1 ; idx >= 0 ; idx--){\n        for(int buy = 0 ; buy < buy_options ; buy++){\n            for(int cap = 1 ; cap <= capacity ; cap++){\n                if(buy){\n                    int ahead_sell = after[0][cap];   // if decided to buy\n                    int ahead_buy = after[1][cap];    // if decided to not buy (and look ahead)\n                    curr[buy][cap] = max(-prices[idx] + ahead_sell, 0 + ahead_buy);\n                }else{\n                    int ahead_can_buy = after[1][cap-1];\n                    int ahead_must_sell = after[0][cap]; \n                    curr[buy][cap] = max(prices[idx] + ahead_can_buy, 0 + ahead_must_sell);\n                }\n            }\n        }\n        after = curr;\n    }\n    return after[1][2];\n}",
        "naive_explanation": "No explanation provided",
        "optimized_explanation": "Space-optimized (3D -> 2D)",
        "naive_complexity": "No complexity provided",
        "optimized_complexity": "Time: O(N*2*3) , Space:  O(const)"
    },
    {
        "problem_name": "Buy Sell Stock 4",
        "naive_code": "(max k transactions allowed) (tran_No => current transaction in action)\nint recurse(int idx, int tran_No, int k, const vector<int> &prices){\n    // base cases \n    if(tran_No == 2*k || idx == prices.size()){\n        return 0;\n    }\n    if(tran_No % 2 == 0){    // BUY (all even tranNo are always buy(check example above function))\n        return max(-prices[idx] + recurse(idx+1, tran_No+1, k, prices), \n                0 + recurse(idx+1, tran_No, k, prices));\n    }\n    // SELL (if tranNo not even)\n    return max(prices[idx] + recurse(idx+1, tran_No+1, k, prices),\n                0 + recurse(idx+1, tran_No, k, prices));\n}\n\nint tabulation_approach(const vector<int> &prices, int k){\n    int n = prices.size();\n    vector<vector<int>> dp(n+1, vector<int>(2*k+1, 0));   // since if there are 2 trans(=k) allowed => 4 operations(B, S, B, S)\n\n    for(int idx = n-1 ; idx >= 0 ; idx--){\n        for(int tran_No = 2*k-1 ; tran_No >= 0 ; tran_No--){\n            if((tran_No % 2) == 0){\n                dp[idx][tran_No] = max(-prices[idx] + dp[idx+1][tran_No+1], \n                                        0 + dp[idx+1][tran_No]);\n            }else{\n                dp[idx][tran_No] = max(prices[idx] + dp[idx+1][tran_No+1], \n                                        0 + dp[idx+1][tran_No]); \n            }\n        }\n    }return dp[0][0];\n}",
        "optimized_code": "int hyper_optimized_approach(const vector<int> &prices, int k){    // convert s1 -> s2 \n    int n = prices.size();      \n    vector<int> after(2*k + 1, 0);\n    vector<int> curr(2*k + 1, 0);\n\n    // core logic\n    for(int idx = n-1 ; idx >= 0 ; idx--){\n        for(int tran_No = 2*k-1 ; tran_No >= 0 ; tran_No--){\n            if((tran_No % 2) == 0){\n                curr[tran_No] = max(-prices[idx] + after[tran_No+1], \n                                    0 + after[tran_No]);\n            }else{\n                curr[tran_No] = max(prices[idx] + after[tran_No+1], \n                                    0 + after[tran_No]);\n            }\n        }\n        after = curr;\n    }\n    return after[0];\n}",
        "naive_explanation": "No explanation provided",
        "optimized_explanation": "Space-optimized (2D -> 1D)",
        "naive_complexity": "No complexity provided",
        "optimized_complexity": "Time: O(N*2*k) , Space:  O(4k + 2)"
    },
    {
        "problem_name": "Coin Change Min Coins",
        "naive_code": "int recursion_approach(int idx, int amount, vector<int>& coins) {\n    // Base case: At the first coin.\n    if (idx == 0) {\n        // If the amount is divisible by the coin value.\n        if (amount % coins[0] == 0) {\n            return amount / coins[0];\n        }\n        // Otherwise, it's not possible to make the amount.\n        return 1e9; // A large value indicating impossibility.\n    }\n\n    // Don't take the current coin.\n    int not_take = recursion_approach(idx - 1, amount, coins);\n\n    // Take the current coin.\n    int take = 1e9;\n    if (coins[idx] <= amount) {\n        // 1 (for the current coin) + result for the remaining amount.\n        take = 1 + recursion_approach(idx, amount - coins[idx], coins);\n    }\n\n    return min(take, not_take);\n}",
        "optimized_code": "int hyper_optimized_approach(int n, int amount, vector<int>& coins) {\n    vector<int> prev(amount + 1, 1e9);\n\n    // Base case: 0 coins are needed for amount 0.\n    prev[0] = 0;\n    \n    // Initialize for the first coin.\n    for(int T=0; T<=amount; T++){\n        if(T % coins[0] == 0)\n            prev[T] = T / coins[0];\n    }\n\n    // Iterate through the rest of the coins.\n    for (int idx = 1; idx < n; idx++) {\n        // Iterate through all amounts.\n        for (int T = 0; T <= amount; T++) {\n            int notTake = prev[T];\n            int take = 1e9;\n            if (coins[idx] <= T) {\n                take = 1 + prev[T - coins[idx]];\n            }\n            prev[T] = min(take, notTake);\n        }\n    }\n    \n    int result = prev[amount];\n    return (result >= 1e9) ? -1 : result; // Return -1 if not possible.\n}",
        "naive_explanation": "No explanation provided",
        "optimized_explanation": "Space-optimized DP using a single 1D array. prev[i] stores the minimum coins needed for amount 'i'.",
        "naive_complexity": "No complexity provided",
        "optimized_complexity": "Time: O(n * amount), Space: O(amount)."
    },
    {
        "problem_name": "Count Subsets With Given Sum",
        "naive_code": "int recursion_approach(int idx, int target, vector<int>& arr) {\n    // Base case: If we are at the first element.\n    if (idx == 0) {\n        if(target == 0 && arr[0] == 0) return 2; // Two choices: pick or not pick the 0\n        if(target == 0 || target == arr[0]) return 1; // One choice\n        return 0;\n    }\n\n    // Don't include the current element in the subset.\n    int not_take = recursion_approach(idx - 1, target, arr);\n\n    // Include the current element if its value is not greater than the remaining target.\n    int take = 0;\n    if (arr[idx] <= target) {\n        take = recursion_approach(idx - 1, target - arr[idx], arr);\n    }\n\n    // Return the sum of possibilities from both branches.\n    return take + not_take;\n}",
        "optimized_code": "int hyper_optimized_approach(int n, int k, vector<int>& arr) {\n    // prev[i] will store the count of subsets with sum 'i'.\n    vector<int> prev(k + 1, 0);\n\n    // Base case for the first element\n    if(arr[0] == 0) prev[0] = 2; // Two choices for 0: pick or not pick\n    else prev[0] = 1; // Only one choice for non-zero: not pick\n    \n    if(arr[0] != 0 && arr[0] <= k) prev[arr[0]] = 1;\n\n\n    // Iterate through the rest of the array elements.\n    for (int idx = 1; idx < n; idx++) {\n        // Iterate backwards from the target sum.\n        for (int target = k; target >= 0; target--) {\n            int not_take = prev[target];\n            int take = 0;\n            if(arr[idx] <= target) take = prev[target - arr[idx]];\n            \n            prev[target] = take + not_take;\n        }\n    }\n    \n    // The final answer is the number of ways to form the target sum 'k'.\n    return prev[k];\n}",
        "naive_explanation": "No explanation provided",
        "optimized_explanation": "Space-optimized DP using a single 1D integer array (prev) to store the counts of subsets for each possible sum.",
        "naive_complexity": "No complexity provided",
        "optimized_complexity": "Time: O(n * target), Space: O(target)."
    },
    {
        "problem_name": "Distinct Subseq",
        "naive_code": "int recursion_approach(int idx1, int idx2, string &s1, string &s2){\n    // base case(returns either 1 or 0 to determine the count)\n    if(idx2 < 0){\n        return 1;   // Found a valid subsequence\n    }\n    if(idx1 < 0 && idx2 >= 0){\n        return 0;      // s1 exhausted, but s2 is not\n    }\n    // exploring all possibilities and summing up the results\n    if(s1[idx1] == s2[idx2]){\n        return recursion_approach(idx1 - 1, idx2 - 1, s1, s2) + recursion_approach(idx1 - 1, idx2, s1, s2);\n    }\n    return recursion_approach(idx1 - 1, idx2, s1, s2);\n    cout << \"Time Complexity: O(Exponential)\" << endl;\n    cout << \"Space Complexity: O(n + m)  (recursion stack space)\" << endl;\n}\n\n// memoization (due to overlapping subproblems)  (TOP-DOWN)\nint memoization_approach(int i, int j, string &s1, string &s2, vector<vector<int>> dp){\n    // base cases same as recursion approach\n    if(j < 0){\n        return 1;\n    }\n    if(i < 0 && j >= 0){\n        return 0;\n    }\n    if(dp[i][j] != -1){            // avoid already solved problem\n        return dp[i][j];\n    }\n    if(s1[i] == s2[j]){\n        return dp[i][j] = memoization_approach(i-1, j-1, s1, s2, dp) + memoization_approach(i-1, j, s1, s2, dp);\n    }\n    return dp[i][j] = memoization_approach(i-1, j, s1, s2, dp);\n    cout << \"TC : O(N x M)\" << endl; \n    cout << \"SC : O(N x M) + O(N x M)\" << endl; \n} \n\n// (BOTTOM-UP)\nint tabulation_approach(string &s1, string &s2){\n    vector<vector<int>> dp(s1.size() + 1, vector<int>(s2.size() + 1, 0)); // 1-based indexing (table size inc by 1 to deal with negative indexes)\n    // base cases -> dp logic (to avoid recursion calls)\n    for(int i = 0 ; i <= s1.size() ; i++){\n        dp[i][0] = 1;                        // analogous to finding a valid subseq \n    }\n    for(int j = 1 ; j <= s2.size() ; j++){\n        dp[0][j] = 0;                         // analogous to case where s1 was exhausted (out-of-index) bu not s2\n    }\n    // going from start(bottom) -> end(up) \n    for(int i = 1 ; i <= s1.size() ; i++){\n        for(int j = 1 ; j <= s2.size() ; j++){\n            if(s1[i-1] == s2[j-1]){\n                dp[i][j] = dp[i-1][j-1] + dp[i-1][j];\n            }else{\n                dp[i][j] = dp[i-1][j];\n            }\n        }\n    }return dp[s1.size()][s2.size()];      // last box contains optimal solution\n    cout << \"TC : O(N + M + N*M)\" << endl; \n    cout << \"SC : O(N x M)\" << endl; \n}",
        "optimized_code": "int hyper_optimized_approach(string &s1, string &s2){    // convert s1 -> s2 \n    int n = s1.size();\n    int m = s2.size();\n    vector<int> prev(m + 1, 0);\n\n    // dp logic -> 1-D array logic\n    prev[0] = 1;\n\n    for(int i = 0 ; i <= n ; i++){\n        for(int j = m ; j >= 1 ; j--){\n            if(s1[i-1] == s2[j-1]){\n                prev[j] = prev[j-1] + prev[j];\n            }else{\n                continue;    // no change (same value remains)\n            }\n        }\n    }return prev[m];\n}",
        "naive_explanation": "No explanation provided",
        "optimized_explanation": "Space-optimized 1D DP",
        "naive_complexity": "No complexity provided",
        "optimized_complexity": "Time: O(n * m) , Space:  O(m)"
    },
    {
        "problem_name": "Edit Distance",
        "naive_code": "int recursion_approach(int i, int j, string &s1, string &s2){\n    // base cases \n    if(i < 0){           // s1 has exhausted \n    // s1-> \"\"horse, s2 -> \"ro\" then to make \"\" -> \"ro\" we need 2(=idx2+1) insertions\n        return (j + 1);\n    }\n    if(j < 0){           // s2 has exhausted \n    // s1 -> \"horse\", s2 -> \"\" then to make \"horse\" -> \"\" we need 5(=idx1 + 1) deletions\n        return (i + 1);\n    }\n    if(s1[i] == s2[j]){\n        // if current letters match, simply shrink the strings by -1 (no operations applied)\n        return 0 + recursion_approach(i-1, j-1, s1, s2);\n    }    \n    int insert = 1 + recursion_approach(i, j-1, s1, s2);    // INSERTION (hypothetically inserted the letter s2[j] in s1 ahead of ith position)\n    int del = 1 + recursion_approach(i-1, j, s1, s2);    // DELETION (delete s1[i] and move idx one step behind if it doesnt match with s2[j])\n    int replace = 1 + recursion_approach(i-1, j-1, s1, s2);  // REPLACE (replace s1[i] with s2[j] if they dont match -> to match them and hence shrink idx by 1) \n    return min(min(insert, replace), del);\n    cout << \"TC : O(Exponential)\" << endl;\n    cout << \"SC : 2 * O(N + M) (recursion + auxiliary)\" << endl;\n}\n\n// (BOTTOM-UP)\nint tabulation_approach(string &s1, string &s2){\n    int n = s1.size();\n    int m = s2.size();\n    vector<vector<int>> dp(n+1, vector<int>(m+1, 0));\n\n    // initial fillings (analogous to the recursion cases)\n    for(int j = 0 ; j <= m ; j++){\n        dp[0][j] = j;\n    }\n    for(int i = 0 ; i <= n ; i++){\n        dp[i][0] = i;\n    }\n    for(int i = 1 ; i <= n ; i++){\n        for(int j = 1 ; j <= m ; j++){\n            if(s1[i-1] == s2[j-1]){\n                dp[i][j] = dp[i-1][j-1];\n            }else{\n                dp[i][j] = 1 + min(dp[i][j-1], min(dp[i-1][j], dp[i-1][j-1]));\n            }\n        }\n    }return dp[n][m];\n    cout << \"TC : O(N + M + N*M)\" << endl;\n    cout << \"SC : O(N*M) (2D-DP grid)\" << endl;\n}",
        "optimized_code": "int hyper_optimized_approach(string &s1, string &s2){    // convert s1 -> s2 \n    int n = s1.size();\n    int m = s2.size();\n    vector<int> prev(m+1, 0), curr(m+1, 0);\n\n    // initial fillings (analogous to tabulation case)\n    for(int j = 0 ; j <= m ; j++){\n        prev[j] = j;\n    }\n    for(int i = 1 ; i <= n ; i++){\n        curr[0] = i;\n        for(int j = 1 ; j <= m ; j++){\n            if(s1[i-1] == s2[j-1]){\n                curr[j] = prev[j-1];\n            }else{\n                curr[j] = 1 + min(curr[j-1], min(prev[j], prev[j-1]));\n            }\n        }\n        prev = curr;\n    }\n    return prev[m];\n}",
        "naive_explanation": "No explanation provided",
        "optimized_explanation": "Space-optimized 1D DP",
        "naive_complexity": "No complexity provided",
        "optimized_complexity": "Time: O(n * m) , Space:  O(m)"
    },
    {
        "problem_name": "Largest Div Subset",
        "naive_code": "(TC : O(2^n) SC : O(n) auxiliary stack space)\n// int recursion_approach(int i, int prev, const vector<int> &arr){\n//     // base case (when you have traversed the entire array) \n//     if(i == arr.size()){\n//         return 0;\n//     }\n//     int take = 0;\n//     int notTake = 0 + recursion_approach(i+1, prev, arr);\n//     if(arr[i] > arr[prev] || prev == -1){     // since 1st element (prev = -1) can be taken unconditionally\n//         take = 1 + recursion_approach(i+1, i, arr);\n//     }\n//     return max(take, notTake);\n// }",
        "optimized_code": "int hyper_optimized_approach(vector<int> &arr){\n    int n = arr.size();\n    vector<int> dp(n, 1);\n    int maxi = 1;\n    \n    sort(arr.begin(), arr.end());\n    // main logic (hash array to help in printing LIS sequence)\n    for(int cur = 0 ; cur < n ; cur++){\n        for(int prev = 0 ; prev < cur ; prev++){\n            if(arr[cur] % arr[prev] == 0 && 1 + dp[prev] > dp[cur]){   // valid increasing\n                dp[cur] = 1 + dp[prev];\n            }\n        }\n        maxi = max(maxi, dp[cur]);\n    }\n    return maxi;\n}",
        "naive_explanation": "No explanation provided",
        "optimized_explanation": "Space-optimized 1D DP",
        "naive_complexity": "No complexity provided",
        "optimized_complexity": "Time: O(n^2) , Space:  O(n)"
    },
    {
        "problem_name": "Lbs",
        "naive_code": "",
        "optimized_code": "int hyper_optimized_approach(const vector<int> &arr){\n    int n = arr.size();\n    vector<int> dp_f(n, 1);\n    \n    // main logic (figuring out LIS from front traversal)\n    for(int cur = 0 ; cur < n ; cur++){\n        for(int prev = 0 ; prev < cur ; prev++){\n            if(arr[cur] > arr[prev] && 1 + dp_f[prev] > dp_f[cur]){   // valid increasing\n                dp_f[cur] = 1 + dp_f[prev];\n            }\n        }\n    }\n\n    vector<int> dp_b(n, 1);\n    // main logic (figuring out LIS from rear traversal)\n    for(int cur = n-1 ; cur >= 0 ; cur--){\n        for(int prev = n-1 ; prev > cur ; prev--){\n            if(arr[cur] > arr[prev] && 1 + dp_b[prev] > dp_b[cur]){   // valid increasing\n                dp_b[cur] = 1 + dp_b[prev];\n            }\n        }\n    }\n\n    vector<int> bitonic(n, 0);\n    int maxi = 1;\n    for(int i = 0 ; i < n ; i++){\n        bitonic[i] = (dp_f[i] + dp_b[i] - 1);   // -1 to avoid double counting of peak element\n        maxi = max(maxi, bitonic[i]);\n    }\n    return maxi;\n}",
        "naive_explanation": "No explanation provided",
        "optimized_explanation": "Space-optimized 1D DP",
        "naive_complexity": "No complexity provided",
        "optimized_complexity": "Time: O(n^2) , Space: O(n)"
    },
    {
        "problem_name": "Lcs",
        "naive_code": "int recursion_approach(int idx1, int idx2, string &s1, string &s2){\n    if(idx1 < 0 || idx2 < 0){\n        return 0;\n    }\n    if(s1[idx1] == s2[idx2]){\n        return (1 + recursion_approach(idx1 - 1, idx2 - 1, s1, s2));\n    }\n    cout << \"Time Complexity: O(Exponential)\" << endl;\n    cout << \"Space Complexity: O(n1 + n2)  (recursion stack space)\" << endl;\n    return 0 + max(recursion_approach(idx1 - 1, idx2, s1, s2), recursion_approach(idx1, idx2 - 1, s1, s2));\n}",
        "optimized_code": "int hyper_optimized_approach(string &s1, string &s2){\n    int n = s1.size();\n    int m = s2.size();\n    vector<int> prev(m + 1, 0), curr(m + 1, 0);\n\n    // base cases\n    for(int j = 0 ; j <= m ; j++){\n        prev[j] = 0;\n    }\n    \n    for(int i = 1 ; i <= n ; i++){\n        for(int j = 1 ; j <= m ; j++){\n            if(s1[i-1] == s2[j-1]){\n                curr[j] = 1 + prev[j-1];\n            }else{\n                curr[j] = 0 + max(prev[j], curr[j-1]);\n            }\n        }\n        prev = curr;\n    }\n    return prev[m];\n}",
        "naive_explanation": "No explanation provided",
        "optimized_explanation": "Space-optimized 1D DP",
        "naive_complexity": "No complexity provided",
        "optimized_complexity": "Time: O(n1 * n2) , Space:  O(min(n1, n2))"
    },
    {
        "problem_name": "Lis",
        "naive_code": "(TC : O(2^n) SC : O(n) auxiliary stack space)\nint recursion_approach(int i, int prev, const vector<int> &arr){\n    // base case (when you have traversed the entire array) \n    if(i == arr.size()){\n        return 0;\n    }\n    int take = 0;\n    int notTake = 0 + recursion_approach(i+1, prev, arr);\n    if(arr[i] > arr[prev] || prev == -1){     // since 1st element (prev = -1) can be taken unconditionally\n        take = 1 + recursion_approach(i+1, i, arr);\n    }\n    return max(take, notTake);\n}",
        "optimized_code": "int hyper_optimized_approach(const vector<int> &arr){\n    int n = arr.size();\n    vector<int> dp(n, 1);\n    int maxi = 1;\n    \n    // main logic (hash array to help in printing LIS sequence)\n    for(int cur = 0 ; cur < n ; cur++){\n        for(int prev = 0 ; prev < cur ; prev++){\n            if(arr[cur] > arr[prev] && 1 + dp[prev] > dp[cur]){   // valid increasing\n                dp[cur] = 1 + dp[prev];\n            }\n        }\n        maxi = max(maxi, dp[cur]);\n    }\n    return maxi;\n}",
        "naive_explanation": "No explanation provided",
        "optimized_explanation": "Space-optimized 1D DP",
        "naive_complexity": "No complexity provided",
        "optimized_complexity": "Time: O(n^2) , Space:  O(n)"
    },
    {
        "problem_name": "Lis Binary Search",
        "naive_code": "",
        "optimized_code": "(using Binary Search concept)\n\nint hyper_optimized_approach(const vector<int> &arr){\n    vector<int> temp;\n    temp.push_back(arr[0]);\n    int len = 1;\n    int n = arr.size();\n\n    for(int i = 1 ; i < n ; i++){\n        if(arr[i] > temp.back()){\n            temp.push_back(arr[i]);\n            len++;\n        }\n        else{\n            // find the index of the smallest number >= arr[i]\n            int ind = lower_bound(temp.begin(), temp.end(), arr[i]) - temp.begin();\n            temp[ind] = arr[i];   // replace that number with arr[i]\n        }\n    }\n    return len;               // length of LIS is size of temp vector\n}",
        "naive_explanation": "No explanation provided",
        "optimized_explanation": "Space-optimized 1D (replicating fake LIS space as only goal is to get length of LIS)",
        "naive_complexity": "No complexity provided",
        "optimized_complexity": "Time: O(n * log(n)) , Space:  O(n)"
    },
    {
        "problem_name": "Longest Palindromic Subsequence",
        "naive_code": "int recursion_approach(int idx1, int idx2, string &s1, string &s2){\n    if(idx1 < 0 || idx2 < 0){\n        return 0;\n    }\n    if(s1[idx1] == s2[idx2]){\n        return (1 + recursion_approach(idx1 - 1, idx2 - 1, s1, s2));\n    }\n    cout << \"Time Complexity: O(Exponential)\" << endl;\n    cout << \"Space Complexity: O(n1 + n2)  (recursion stack space)\" << endl;\n    return max(recursion_approach(idx1 - 1, idx2, s1, s2), recursion_approach(idx1, idx2 - 1, s1, s2));\n}",
        "optimized_code": "int hyper_optimized_approach(string &s1){\n    string s2 = s1;\n    reverse(s2.begin(), s2.end());\n    // int n = s1.size();\n    // int m = s2.size();\n    vector<int> prev(s2.size() + 1, 0), curr(s2.size() + 1, 0);\n\n    // base cases\n    for(int j = 0 ; j <= s2.size() ; j++){\n        prev[j] = 0;\n    }\n    \n    for(int i = 1 ; i <= s1.size() ; i++){\n        for(int j = 1 ; j <= s2.size() ; j++){\n            if(s1[i-1] == s2[j-1]){\n                curr[j] = 1 + prev[j-1];\n            }else{\n                curr[j] = 0 + max(prev[j], curr[j-1]);\n            }\n        }\n        prev = curr;\n    }\n    return prev[s2.size()];\n}",
        "naive_explanation": "No explanation provided",
        "optimized_explanation": "Space-optimized 1D DP",
        "naive_complexity": "No complexity provided",
        "optimized_complexity": "Time: O(n1 * n2) , Space:  O(min(n1, n2))"
    },
    {
        "problem_name": "Lsc",
        "naive_code": "",
        "optimized_code": "int hyper_optimized_approach(vector<string> &arr){\n    int n = arr.size();\n    vector<int> dp(n, 1);\n    int maxi = 1;\n    \n    // main logic (hash array to help in printing LIS sequence)\n    sort(arr.begin(), arr.end(), comp);     // as sequence can start from any element (progressing by 1 character) and not just in chronological order\n\n    for(int cur = 0 ; cur < n ; cur++){\n        for(int prev = 0 ; prev < cur ; prev++){\n            if(checkPossible(arr[cur], arr[prev])){   // valid increasing\n                if(1 + dp[prev] > dp[cur]){\n                    dp[cur] = 1 + dp[prev];\n                }\n            }\n        }\n        maxi = max(maxi, dp[cur]);\n    }\n    return maxi;\n}",
        "naive_explanation": "No explanation provided",
        "optimized_explanation": "Space-optimized 1D DP",
        "naive_complexity": "No complexity provided",
        "optimized_complexity": "Time: O(n^2 * len(s)) , Space:  O(n) + O(nlogn) for sorting"
    },
    {
        "problem_name": "Mcm",
        "naive_code": "(TC : O(exponential) SC : O(n) auxiliary stack space)\nint recursion_approach(int i, int j, const vector<int> &arr){\n    if(i == j){\n        return 0;\n    }\n    int mini = 1e9;\n\n    // recursive logic to partition the matrix at different k values (ABCD -> (A)(BCD) , (AB)(CD) , (ABC)(D))\n    for(int k = i ; k < j ; k++){\n        int steps = (arr[i-1] * arr[k] * arr[j]) + recursion_approach(i, k, arr) + recursion_approach(k+1, j, arr);\n        mini = min(mini, steps);\n    }\n    return mini;\n}",
        "optimized_code": "// (BOTTOM-UP approach) (TC : O(n^3), SC : O(n^2))\nint hyper_optimized_approach(const vector<int> &arr, int size){\n    int n = arr.size();\n    vector<vector<int>> dp(n ,vector<int>(n, 0));\n\n    // main logic\n    for(int i = 0 ; i < n ; i++){\n        dp[i][i] = 0;                   // analogous to rec base cases\n    }\n    for(int i = n-1 ; i >= 1 ; i--){\n        for(int j = i+1 ; j < n ; j++){\n            int mini = 1e9;\n            for(int k = i ; k <= j-1 ; k++){\n                int steps = (arr[i-1] * arr[k] * arr[j]) + dp[i][k] + dp[k+1][j];\n                mini = min(mini, steps);\n            }\n            dp[i][j] = mini;\n        }\n    }\n    return dp[1][n-1];\n}",
        "naive_explanation": "No explanation provided",
        "optimized_explanation": "Space-optimized 2D DP",
        "naive_complexity": "No complexity provided",
        "optimized_complexity": "No complexity provided"
    },
    {
        "problem_name": "Min Cost Cut Stick",
        "naive_code": "(TC : O(exponential) SC : O(n) auxiliary stack space)\nint recursion_approach(int i, int j, vector<int> &cuts){\n    // base case\n    if(i > j){\n        return 0;\n    }\n    int mini = 1e9;\n\n    // recursive logic to partition the stick at different cut positions in arr\n    for(int idx = i ; idx <= j ; idx++){\n        int cost = (cuts[j+1] - cuts[i-1]) + recursion_approach(i, idx-1, cuts) + recursion_approach(idx+1, j, cuts);\n        mini = min(mini, cost);\n    }\n    return mini;\n}",
        "optimized_code": "// (BOTTOM-UP approach) (TC : O(n^3), SC : O(n^2))\nint hyper_optimized_approach(const vector<int> &cuts){\n    int n = cuts.size();\n    vector<vector<int>> dp(n+2 ,vector<int>(n+2, 0));\n\n    // main logic (always loop in oppposite fashion as compared to recursion as bottom up)\n    for(int i = n ; i >= 1 ; i--){\n        for(int j = 1 ; j <= n ; j++){\n            if(i > j){continue;}\n            int mini = 1e9;\n\n            for(int idx = i ; idx<= j ; idx++){\n                int cost = (cuts[j+1] - cuts[i-1]) + dp[i][idx-1] + dp[idx+1][j];\n                dp[i][j] = min(mini, cost);\n            }\n            dp[i][j] = mini;\n        }\n    }\n    return dp[1][n];\n}",
        "naive_explanation": "No explanation provided",
        "optimized_explanation": "Space-optimized 2D DP",
        "naive_complexity": "No complexity provided",
        "optimized_complexity": "No complexity provided"
    },
    {
        "problem_name": "Min Insertions Palindrome",
        "naive_code": "int recursion_approach(int idx1, int idx2, string &s1, string &s2){\n    if(idx1 < 0 || idx2 < 0){\n        return 0;\n    }\n    if(s1[idx1] == s2[idx2]){\n        return (1 + recursion_approach(idx1 - 1, idx2 - 1, s1, s2));\n    }\n    cout << \"Time Complexity: O(Exponential)\" << endl;\n    cout << \"Space Complexity: O(n1 + n2)  (recursion stack space)\" << endl;\n    return max(recursion_approach(idx1 - 1, idx2, s1, s2), recursion_approach(idx1, idx2 - 1, s1, s2));\n}",
        "optimized_code": "int hyper_optimized_approach(string &s1){\n    string s2 = s1;\n    reverse(s2.begin(), s2.end());\n\n    int n = s1.size();\n    int m = s2.size();\n    vector<int> prev(m + 1, 0), curr(m + 1, 0);\n\n    // base cases\n    for(int j = 0 ; j <= m ; j++){\n        prev[j] = 0;\n    }\n    \n    for(int i = 1 ; i <= n ; i++){\n        for(int j = 1 ; j <= m ; j++){\n            if(s1[i-1] == s2[j-1]){\n                curr[j] = 1 + prev[i-1];\n            }else{\n                curr[j] = 0 + max(prev[j], curr[j-1]);\n            }\n        }\n        prev = curr;\n    }\n    int length_lps = prev[m];\n    int min_insertions_to_make_palindrome = (s1.size() - length_lps);\n    return min_insertions_to_make_palindrome;\n}",
        "naive_explanation": "No explanation provided",
        "optimized_explanation": "Space-optimized 1D DP",
        "naive_complexity": "No complexity provided",
        "optimized_complexity": "Time: O(n1 * n2) , Space:  O(min(n1, n2))"
    },
    {
        "problem_name": "Min Operations Transform String",
        "naive_code": "int recursion_approach(int idx1, int idx2, string &s1, string &s2){\n    if(idx1 < 0 || idx2 < 0){\n        return 0;\n    }\n    if(s1[idx1] == s2[idx2]){\n        return (1 + recursion_approach(idx1 - 1, idx2 - 1, s1, s2));\n    }\n    cout << \"Time Complexity: O(Exponential)\" << endl;\n    cout << \"Space Complexity: O(n1 + n2)  (recursion stack space)\" << endl;\n    return max(recursion_approach(idx1 - 1, idx2, s1, s2), recursion_approach(idx1, idx2 - 1, s1, s2));\n}",
        "optimized_code": "int hyper_optimized_approach(string &s1, string &s2, int n, int m){    // convert s1 -> s2 \n    vector<int> prev(m + 1, 0), curr(m + 1, 0);\n\n    // base cases\n    for(int j = 0 ; j <= m ; j++){\n        prev[j] = 0;\n    }\n    \n    for(int i = 1 ; i <= n ; i++){\n        for(int j = 1 ; j <= m ; j++){\n            if(s1[i-1] == s2[j-1]){\n                curr[j] = 1 + prev[j-1];\n            }else{\n                curr[j] = 0 + max(prev[j], curr[j-1]);\n            }\n        }\n        prev = curr;\n    }\n    // abcd(s1) --> anc(s2) \n    // No of deletions = 2 (b, d) [len(abcd) - len(lcs(s1))(=ac)]\n    // No of insertions = 1(n) [len(anc) - len(lcs(s1))(=ac)]\n    int total_min_operations = (s1.size() - prev[m]) + (s2.size() - prev[m]);      // len of lcs stored at prev[m](last idx)\n    return total_min_operations;\n}",
        "naive_explanation": "No explanation provided",
        "optimized_explanation": "Space-optimized 1D DP",
        "naive_complexity": "No complexity provided",
        "optimized_complexity": "Time: O(n1 * n2) , Space:  O(min(n1, n2))"
    },
    {
        "problem_name": "Min Subset Sum Diff",
        "naive_code": "void recursion_approach(int idx, int current_sum, int total_sum, vector<int> &arr, int &min_diff) {\n    // Base case: when all elements have been considered.\n    if (idx < 0) {\n        // The two subset sums are current_sum and (total_sum - current_sum).\n        min_diff = min(min_diff, abs((total_sum - current_sum) - current_sum));\n        return;\n    }\n\n    // Case 1: Include arr[idx] in the current subset.\n    recursion_approach(idx - 1, current_sum + arr[idx], total_sum, arr, min_diff);\n\n    // Case 2: Do not include arr[idx] in the current subset.\n    recursion_approach(idx - 1, current_sum, total_sum, arr, min_diff);\n}",
        "optimized_code": "int hyper_optimized_approach(int n, vector<int>& arr) {\n    int total_sum = 0;\n    for (int x : arr) {\n        total_sum += x;\n    }\n\n    int k = total_sum;\n    vector<bool> prev(k + 1, false);\n    prev[0] = true;\n\n    if (arr[0] <= k) {\n        prev[arr[0]] = true;\n    }\n\n    for (int idx = 1; idx < n; idx++) {\n        for (int target = k; target >= arr[idx]; target--) {\n            prev[target] = prev[target] || prev[target - arr[idx]];\n        }\n    }\n\n    int min_diff = 1e9;\n    // The possible sums for one subset are marked as 'true' in the prev array.\n    // We only need to check up to total_sum/2.\n    for (int s1 = 0; s1 <= total_sum / 2; s1++) {\n        if (prev[s1]) {\n            // s2 = total_sum - s1\n            // diff = abs(s2 - s1) = abs(total_sum - 2*s1)\n            min_diff = min(min_diff, abs(total_sum - 2 * s1));\n        }\n    }\n    return min_diff;\n}",
        "naive_explanation": "Brute-force recursion",
        "optimized_explanation": "Space-optimized 1D-DP.",
        "naive_complexity": "Time: O(2^n), Space: O(n) for recursion stack.",
        "optimized_complexity": "Time: O(n * sum), Space: O(sum)."
    },
    {
        "problem_name": "N Lis",
        "naive_code": "",
        "optimized_code": "int hyper_optimized_approach(const vector<int> &arr){\n    int n = arr.size();\n    vector<int> dp(n, 1);\n    vector<int> count(n, 1);\n    int maxi = 1;\n    \n    // main logic (hash array to help in printing LIS sequence)\n    for(int cur = 0 ; cur < n ; cur++){\n        for(int prev = 0 ; prev < cur ; prev++){\n            if(arr[cur] > arr[prev] && 1 + dp[prev] > dp[cur]){   // valid increasing\n                dp[cur] = 1 + dp[prev];\n                count[cur] = count[prev];               // inherit count\n            }else if(arr[cur] > arr[prev] && 1 + dp[prev] == dp[cur]){   //(when duplicate value of LIS length found in dp)\n                count[cur] += count[prev];              // add count\n            }\n        }\n        maxi = max(maxi, dp[cur]);\n    }\n    int totalCount = 0;\n    for(int i = 0 ; i < n ; i++){\n        if(dp[i] == maxi){\n            totalCount += count[i];\n        }\n    }\n    return totalCount;\n}",
        "naive_explanation": "No explanation provided",
        "optimized_explanation": "Space-optimized 1D DP",
        "naive_complexity": "No complexity provided",
        "optimized_complexity": "Time: O(n^2) , Space:  O(n)"
    },
    {
        "problem_name": "Palindrome Partitioning",
        "naive_code": "(TC : O(exponential) SC : O(n) auxiliary stack space)\nint recursion_approach(int i, const string &s){    // front partitioning\n    int n = s.size();\n    // base cases\n    if(i == n){\n        return 0;\n    }\n    string temp = \"\";\n    int minCost = 1e9;\n    // core recursion logic\n    for(int j = i ; j < n ; j++){\n        temp += s[j];\n        if(isPalidrome(temp)){\n            int cost = 1 + recursion_approach(j + 1, s);\n            minCost = min(minCost, cost);\n        }\n    }\n    return minCost;\n}",
        "optimized_code": "// (BOTTOM-UP approach) (TC : O(n^2 * m), SC : O(n))\nint hyper_optimized_approach(const string &s){\n    int n = s.size();\n    vector<int> dp(n+1, 0);\n\n    dp[n] = 0;  // base case\n\n    for(int i = n-1 ; i >= 0 ; i--){\n        string temp = \"\";\n        int minCost = 1e9;\n        for(int j = i ; j < n ; j++){\n            temp += s[j];\n            if(isPalidrome(temp)){\n                int cost = 1 + dp[j+1];\n                minCost = min(minCost, cost);\n            }\n        }\n        dp[i] = minCost;\n    }\n    return dp[0];\n}",
        "naive_explanation": "No explanation provided",
        "optimized_explanation": "Space-optimized 1D DP",
        "naive_complexity": "No complexity provided",
        "optimized_complexity": "No complexity provided"
    },
    {
        "problem_name": "Partition Equal Subsets",
        "naive_code": "bool recursion_approach(int idx, int target, vector<int> &arr) {\n    if (target == 0) return true;\n    if (idx == 0) return (arr[0] == target);\n\n    bool not_take = recursion_approach(idx - 1, target, arr);\n    bool take = false;\n    if (arr[idx] <= target) {\n        take = recursion_approach(idx - 1, target - arr[idx], arr);\n    }\n    return take || not_take;\n}",
        "optimized_code": "bool hyper_optimized_approach(int n, vector<int> &arr) {\n    int total_sum = 0;\n    for (int x : arr) {\n        total_sum += x;\n    }\n    // If total sum is odd, it cannot be partitioned into two equal halves.\n    if (total_sum % 2 != 0) {\n        return false;\n    }\n    int k = total_sum / 2;\n    vector<bool> prev(k + 1, false);\n    prev[0] = true;\n    if (arr[0] <= k) {\n        prev[arr[0]] = true;\n    }\n\n    for (int idx = 1; idx < n; idx++) {\n        for (int target = k; target >= arr[idx]; target--) {\n            prev[target] = prev[target] || prev[target - arr[idx]];\n        }\n    }\n    return prev[k];\n}",
        "naive_explanation": "Brute-force recursion",
        "optimized_explanation": "Space-optimized 1D DP (sum check for k = total_sum/2)",
        "naive_complexity": "Time: O(2^n), Space: O(n) for recursion stack.",
        "optimized_complexity": "Time: O(n * sum), Space: O(sum)."
    },
    {
        "problem_name": "Partition Max Sum",
        "naive_code": "(TC : O(exponential) SC : O(n) auxiliary stack space)\nint recursion_approach(int i, int k, const vector<int> &arr){    // front partitioning\n    // base case\n    if(i == arr.size()){\n        return 0;\n    }\n    int maxAns = INT_MIN;\n    int maxi = INT_MIN;\n    int len = 0;\n    for(int j = i ; j < (i + k) && j < arr.size() ; j++){\n        len++;\n        maxi = max(maxi, arr[j]);\n        // finding max locally for a partition (ex : [1 15 7] -> max = 15 -> [15 15 15] -> sum = 15(maxi) * 3(len) = 45)\n        int sum = (maxi * len) + recursion_approach(j + 1, k, arr);     // recurse for next partition (independent)\n        maxAns = max(maxAns, sum);\n    }\n    return maxAns;\n}",
        "optimized_code": "// (BOTTOM-UP approach) (TC : O(n*k), SC : O(n))\nint hyper_optimized_approach(int k, const vector<int> &arr){\n    int n = arr.size();\n    vector<int> dp(n + 1, 0);  // dp[i] -> max sum for subarray arr[0...i-1]\n\n    dp[n] = 0; // base case\n\n    for(int i = n-1 ; i >= 0 ; i--){\n        int maxAns = INT_MIN;\n        int maxi = INT_MIN;\n        int len = 0;\n        for(int j = i ; j < (i + k) && j < n ; j++){\n            len++;\n            maxi = max(maxi, arr[j]);\n            int sum = (maxi * len) + dp[j + 1]; // dp[j + 1] -> max sum for subarray arr[0...j]\n            maxAns = max(maxAns, sum);\n        }\n        dp[i] = maxAns;\n    }\n    return dp[0];\n}",
        "naive_explanation": "No explanation provided",
        "optimized_explanation": "Space-optimized 1D DP",
        "naive_complexity": "No complexity provided",
        "optimized_complexity": "No complexity provided"
    },
    {
        "problem_name": "Rod Cutting",
        "naive_code": "int recursion_approach(int idx, int N, vector<int>& prices) {\n    // Base case: At the first piece (length 1).\n    if (idx == 0) {\n        // We can make N cuts of length 1.\n        return N * prices[0];\n    }\n\n    // Don't make a cut of the current length (idx + 1).\n    int not_take = recursion_approach(idx - 1, N, prices);\n\n    // Make a cut of the current length.\n    int take = INT_MIN;\n    int rod_length = idx + 1;\n    if (rod_length <= N) {\n        // We can make more cuts of the same length.\n        take = prices[idx] + recursion_approach(idx, N - rod_length, prices);\n    }\n\n    return max(take, not_take);\n}",
        "optimized_code": "int hyper_optimized_approach(int n, vector<int>& prices) {\n    vector<int> prev(n + 1, 0);\n\n    // Base case: maximum price for a rod of length 'i' using only pieces of length 1.\n    for (int i = 0; i <= n; i++) {\n        prev[i] = i * prices[0];\n    }\n\n    // Iterate through all possible piece lengths (2 to n).\n    for (int idx = 1; idx < n; idx++) {\n        // Iterate through all possible rod lengths.\n        for (int N = 0; N <= n; N++) {\n            int notTake = prev[N];\n            int take = INT_MIN;\n            int rod_length = idx + 1;\n            if (rod_length <= N) {\n                take = prices[idx] + prev[N - rod_length];\n            }\n            prev[N] = max(take, notTake);\n        }\n    }\n    return prev[n];\n}",
        "naive_explanation": "Brute-force recursive solution for Rod Cutting. This is a variation of Unbounded Knapsack where rod lengths are weights and prices are values.",
        "optimized_explanation": "Space-optimized DP using a single 1D array. It iterates through pieces and rod lengths to find the maximum price, equivalent to Unbounded Knapsack.",
        "naive_complexity": "Time: O(Exponential), Space: O(N) for recursion stack depth.",
        "optimized_complexity": "Time: O(N * N), Space: O(N)."
    },
    {
        "problem_name": "Shortest Common Superseq",
        "naive_code": "int recursion_approach(int idx1, int idx2, string &s1, string &s2){\n    if(idx1 < 0 || idx2 < 0){\n        return 0;\n    }\n    if(s1[idx1] == s2[idx2]){\n        return (1 + recursion_approach(idx1 - 1, idx2 - 1, s1, s2));\n    }\n    cout << \"Time Complexity: O(Exponential)\" << endl;\n    cout << \"Space Complexity: O(n1 + n2)  (recursion stack space)\" << endl;\n    return max(recursion_approach(idx1 - 1, idx2, s1, s2), recursion_approach(idx1, idx2 - 1, s1, s2));\n}",
        "optimized_code": "int hyper_optimized_approach(string &s1, string &s2, int n, int m){    // convert s1 -> s2 \n    vector<int> prev(m + 1, 0), curr(m + 1, 0);\n\n    // base cases\n    for(int j = 0 ; j <= m ; j++){\n        prev[j] = 0;\n    }\n    \n    for(int i = 1 ; i <= n ; i++){\n        for(int j = 1 ; j <= m ; j++){\n            if(s1[i-1] == s2[j-1]){\n                curr[j] = 1 + prev[j-1];\n            }else{\n                curr[j] = 0 + max(prev[j], curr[j-1]);\n            }\n        }\n        prev = curr;\n    }\n    // s1 : brute, s2 : groot => len(scs) = len(s1) + len(s2) - len(lcs(s1, s2)) = 5 + 5 - 2 = 8 (bgruoote) (order maintained)\n    int length_scs = (n + m - prev[m]);    // length(lcs) stored at prev[m] \n    return length_scs;\n}",
        "naive_explanation": "No explanation provided",
        "optimized_explanation": "Space-optimized 1D DP",
        "naive_complexity": "No complexity provided",
        "optimized_complexity": "Time: O(n1 * n2) , Space:  O(min(n1, n2))"
    },
    {
        "problem_name": "Subset Sum",
        "naive_code": "int recursion_approach(int idx, int target, vector<int> &arr){\n    if(target == 0){\n        return true;\n    }\n    if(idx == 0){\n        return (arr[0] == target);\n    }\n    bool notTake = recursion_approach(idx - 1, target, arr);\n    bool take = false;\n    if(target >= arr[idx]){\n        take = recursion_approach(idx - 1, target - arr[idx], arr);\n    };\n    return take || notTake;\n}",
        "optimized_code": "int hyper_optimized_approach(int n, int target, vector<int> &arr){\n    vector<bool> prev(target + 1, false);\n    \n    // base cases\n    prev[0] = true;\n    if(arr[0] <= target){\n        prev[arr[0]] = true;\n    }\n    for(int idx = 1 ; idx < n ; idx++){\n        for(int t = target ; t >= 0 ; t--){\n            prev[t] = prev[t] || (t >= arr[idx] ? prev[t - arr[idx]] : false);\n        }\n    }\n    return prev[target];\n}",
        "naive_explanation": "Brute-force recursion",
        "optimized_explanation": "Space-optimized 1D DP",
        "naive_complexity": "Time: O(2^n), Space: O(n) for recursion stack.",
        "optimized_complexity": "Time: O(n * target), Space: O(target)."
    },
    {
        "problem_name": "Target Sum",
        "naive_code": "int recursion_approach(int idx, int current_sum, int target, vector<int>& nums) {\n    // Base case: When all numbers have been processed.\n    if (idx < 0) {\n        return (current_sum == target) ? 1 : 0;\n    }\n\n    // Explore the path where we subtract the current number.\n    int subtract_count = recursion_approach(idx - 1, current_sum - nums[idx], target, nums);\n\n    // Explore the path where we add the current number.\n    int add_count = recursion_approach(idx - 1, current_sum + nums[idx], target, nums);\n\n    // Total ways is the sum of ways from both paths.\n    return subtract_count + add_count;\n}",
        "optimized_code": "int hyper_optimized_approach(int n, int target, vector<int>& nums) {\n    int total_sum = 0;\n    for(int x : nums) total_sum += x;\n\n    // Conditions for impossibility.\n    // 1. The target sum must be achievable.\n    // 2. (total_sum - target) must be non-negative and even.\n    if (total_sum - target < 0 || (total_sum - target) % 2 != 0) {\n        return 0;\n    }\n\n    // This problem reduces to finding the number of subsets with sum s2,\n    // where s2 = (total_sum - target) / 2.\n    int s2 = (total_sum - target) / 2;\n    \n    vector<int> prev(s2 + 1, 0);\n    prev[0] = 1;\n    \n    // This is now the 'Count Subsets with Sum' problem.\n    for (int i = 0; i < n; i++) {\n        for (int t = s2; t >= nums[i]; t--) {\n            prev[t] = prev[t] + prev[t - nums[i]];\n        }\n    }\n    return prev[s2];\n}",
        "naive_explanation": "Brute-force recursion that explores both adding and subtracting each number to find how many combinations result in the target sum.",
        "optimized_explanation": "This problem is transformed into 'Count Subsets with Given Sum'. We find the number of subsets that sum to (total_sum + target) / 2. This is solved with a 1D DP array.",
        "naive_complexity": "Time: O(2^n), Space: O(n) for recursion stack.",
        "optimized_complexity": "Time: O(n * sum), Space: O(sum)."
    },
    {
        "problem_name": "Unbounded Knapsack",
        "naive_code": "int recursion_approach(int idx, int maxWeight, vector<int> &weights, vector<int> &values){\n    if(idx == 0){\n        return (weights[0] <= maxWeight) ? (int(maxWeight / weights[0]) * values[0]) : 0;\n    }\n\n    int notTake = recursion_approach(idx - 1, maxWeight, weights, values);\n    int take = INT_MIN;\n    if(weights[idx] <= maxWeight){\n        take = values[idx] + recursion_approach(idx, maxWeight - weights[idx], weights, values);\n    }\n    return max(take, notTake);\n}",
        "optimized_code": "int hyper_optimized_approach(int n, int maxWeight, vector<int> &weights, vector<int> &values){\n    vector<int> prev(maxWeight + 1, 0);\n    for(int w = 0 ; w <= maxWeight ; w++){\n        prev[w] = (int(w / weights[0]) * values[0]);\n    }\n\n    // Iterate through the rest of the items.\n    for(int idx = 1 ; idx < n ; idx++){\n        // Iterate forwards through the weights.\n        for(int w = 0 ; w <= maxWeight ; w++){\n            int notTake = 0 + prev[w];\n            int take = 0;\n            if(weights[idx] <= w){\n                // prev[w - weights[idx]] already contains the optimized value\n                // which might include the current item.\n                take = values[idx] + prev[w - weights[idx]];\n            }\n            prev[w] = max(take, notTake);\n        }\n    }\n    return prev[maxWeight];\n}",
        "naive_explanation": "Brute force recursion",
        "optimized_explanation": "Space-optimized 1D-DP using a single 1D array. The inner loop runs forwards, allowing an item to contribute to the knapsack value multiple times in the same pass.",
        "naive_complexity": "Time: O(Exponential), Space: O(maxWeight) for recursion stack depth in the worst case.",
        "optimized_complexity": "Time: O(n * maxWeight), Space: O(maxWeight)."
    },
    {
        "problem_name": "Wildcard Match",
        "naive_code": "bool recursion_approach(int i, int j, string &s1, string &s2){\n    // base cases \n    if(i < 0 && j < 0){           // if both s1 and s2 have been exhausted (match success)\n        return true;\n    }\n    if(i < 0 && j >= 0){\n        return false;            // \"\"abcd and \"aced\" -> comparision is anyways over\n    }\n    if(j < 0 && i >= 0){                      // interesting case\n        // (s1)\"***\" and (s2)\"\" ==> match only if remaining s1 is all * (check ground rules) , else no match\n        for(int k = i ; k >= 0 ; k--){\n            if(s1[k] != '*'){\n                return false;\n            } \n        }return true;\n    }\n    if(s1[i] == s2[j] || s1[i] == '?'){\n        // ab? and abd are matching (so move both indexes backwards)\n        return recursion_approach(i-1, j-1, s1, s2);\n    }\n    if(s1[i] == '*'){    \n    // ab* and abcd => [* is considered empty](ab and abcd) or [* is not considered empty](ab* and abc)\n        return recursion_approach(i-1, j, s1, s2) || recursion_approach(i, j-1, s1, s2);\n    }\n    return false;       // aec and abc => when comparing 'e' and 'b' scenario (strings are ofc not matching)\n    cout << \"TC : O(Exponential)\" << endl;\n    cout << \"SC : O(N + M) (auxiliary)\" << endl;\n}\n\n// (BOTTOM-UP)\nbool tabulation_approach(string &s1, string &s2){\n    int n = s1.size();\n    int m = s2.size();\n    vector<vector<bool>> dp(n+1, vector<bool>(m+1, false));     // 1-based indexing\n\n    // cases analogous to recursion base cases\n    dp[0][0] = true;\n    for(int j = 1 ; j <= m ; j++){\n        dp[0][j] = false;\n    }\n    for(int i = 1 ; i <= n ; i++){\n        bool flag = true;\n        for(int k = 0 ; k <= i ; k++){\n            if(s1[k] != '*'){\n                flag = !flag;\n                dp[i][0] = flag;\n            }\n        }\n        dp[i][0] = flag;\n    }\n    // main logic\n    for(int i = 1 ; i <= n ; i++){\n        for(int j = 1 ; j <= m ; j++){\n            if(s1[i-1] == s2[j-1] || s1[i-1] == '?'){\n                dp[i][j] = dp[i-1][j-1];\n            }else if(s1[i-1] == '*'){\n                dp[i][j] = dp[i-1][j] || dp[i][j-1];\n            }else{\n                dp[i][j] = false;\n            }\n        }\n    }return dp[n][m];\n}",
        "optimized_code": "bool hyper_optimized_approach(string &s1, string &s2){    // convert s1 -> s2 \n    int m = s2.size();\n    int n = s1.size();\n    vector<bool> prev(m+1, false), curr(m+1, false);\n\n    prev[0] = true;\n    for(int j = 1 ; j <= m ; j++){\n        prev[j] = false;\n    }\n    for(int i = 1 ; i <= n ; i++){\n        // for every row 'i' you are assiging value at [0]  (first column : [i][0])\n        bool flag = true;\n        for(int k = 0 ; k <= i ; k++){\n            if(s1[k] != '*'){\n                flag = false;\n                break;\n            }\n        }\n        curr[0] = flag;       \n\n        for(int j = 1 ; j <= m ; j++){\n            if(s1[i-1] == s2[j-1] || s1[i-1] == '?'){\n                curr[j] = prev[j-1];\n            }else if(s1[i-1] == '*'){\n                curr[j] = prev[j] || curr[j-1];\n            }else{\n                curr[j] = false;\n            }\n        }\n        prev = curr;\n    }\n    return prev[m];\n}",
        "naive_explanation": "No explanation provided",
        "optimized_explanation": "Space-optimized 1D DP",
        "naive_complexity": "No complexity provided",
        "optimized_complexity": "Time: O(n * m) , Space:  O(m)"
    }
]