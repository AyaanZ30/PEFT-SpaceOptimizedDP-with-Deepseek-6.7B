{"problem_name": "01 Knapsack", "prompt": "You are given two arrays: one representing the weights of items and the other their corresponding values. You are also given the capacity of a knapsack. Formulate a space-optimized dynamic programming algorithm to find the maximum total value that can be obtained without exceeding the knapsack\u2019s capacity.", "space_optimal_solution": "int hyper_optimized_approach(vector<int> &weights, vector<int> &values, int n, int maxWeight){\n    vector<int> prev(maxWeight + 1, 0);\n    for(int w = weights[0] ; w <= maxWeight ; w++){\n        prev[w] = values[0];\n    }\n    for(int idx = 1 ; idx < n ; idx++){\n        for(int w = maxWeight ; w >= 0 ; w--){\n            int notTake = 0 + prev[w];\n            int take = INT_MIN;\n            if(weights[idx] <= w){\n                take = values[idx] + prev[w - weights[idx]];\n            }\n            prev[w] = max(take, notTake);\n        }\n    }\n    return prev[maxWeight];\n}", "main_function": "int main(){\n    int n, bag_capacity;\n    cout << \"Enter number of items: \";\n    cin >> n;\n\n    cout << \"Enter bag capacity: \";\n    cin >> bag_capacity;\n\n    vector<int> weights(n), values(n);\n\n    cout << \"Enter weights : \";\n    for(int i = 0; i < n; i++){\n        cin >> weights[i];\n    }\n    cout << \"Enter values : \";\n    for(int i = 0; i < n; i++){\n        cin >> values[i];\n    }\n\n    cout << \"Max cost in knapsack : \" << hyper_optimized_approach(weights, values, n, bag_capacity) << endl;\n    return 0;\n}"}
{"problem_name": "Bool Eval T", "prompt": "No prompt provided.", "space_optimal_solution": "// (BOTTOM-UP approach)\nint hyper_optimized_approach(const vector<char> &arr){\n    int n = arr.size();\n    vector<vector<vector<int>>> dp(n, vector<vector<int>>(n, vector<int>(2, 0)));\n\n    // base cases analogy (check recursion)\n    for(int i = 0 ; i < n ; i += 2){\n        dp[i][i][1] = (arr[i] == 'T') ? 1 : 0;\n        dp[i][i][0] = (arr[i] == 'F') ? 1 : 0;\n    }\n    // main logic (always loop in oppposite fashion as compared to recursion as bottom up)\n    for(int i = n - 1 ; i >= 0 ; i -= 2){       // i moves only on operands\n        for(int j = i + 2 ; j < n ; j += 2){   // j moves only on operands\n            for(int isTrue = 0 ; isTrue <= 1 ; isTrue++){\n                if(i > j){continue;}\n                int total_ways = 0;\n\n                for(int operator_idx = i + 1 ; operator_idx <= j - 1 ; operator_idx += 2){\n                    int leftTrue = dp[i][operator_idx - 1][1];    // no of ways left partition can be true\n                    int leftFalse = dp[i][operator_idx - 1][0];   // no of ways left partition can be false\n                    int rightTrue = dp[operator_idx + 1][j][1];   // no of ways right partition can be true\n                    int rightFalse = dp[operator_idx + 1][j][0];  // no of ways right partition can be false\n\n                    if(arr[operator_idx] == '&'){\n                        total_ways += (isTrue == 1) ? ((leftTrue * rightTrue)) : ((leftTrue * rightFalse) + (leftFalse * rightTrue) + (leftFalse * rightFalse));     // for AND : (only T & T = T)\n                    }else if(arr[operator_idx] == '|'){\n                        total_ways += (isTrue == 1) ? ((leftTrue * rightTrue) + (leftTrue * rightFalse) + (leftFalse * rightTrue)) : ((leftFalse * rightFalse));   // for OR : (T | T = T), (T | F = T), (F | T = T)\n                    }else{\n                        total_ways += (isTrue == 1) ? ((leftTrue * rightFalse) + (leftFalse * rightTrue)) : ((leftTrue * rightTrue) + (leftFalse * rightFalse));   // for XOR : (T ^ F = T), (F ^ T = T)\n                    }\n                }\n                dp[i][j][isTrue] = total_ways;\n            }\n        }\n    }\n    return dp[0][n-1][1];\n}", "main_function": "int main(){\n    int n;\n    cout << \"Enter number of characters: \";\n    cin >> n;\n\n    vector<char> arr(n);\n\n    cout << \"Enter the characters :\" << endl;\n    for(int i = 0 ; i < n ; i++){\n        cout << \"C\" << i + 1 << \" : \";\n        cin >> arr[i];\n    }\n    printArray(arr);\n\n    cout << \"T can be obtained in : \" << hyper_optimized_approach(arr) <<\" ways.\" << endl;\n    return 0;\n}"}
{"problem_name": "Burst Balloons", "prompt": "No prompt provided.", "space_optimal_solution": "// (BOTTOM-UP approach) (TC : O(n^3) SC : O(n^2) for DP table)\nint hyper_optimized_approach(const vector<int> &costs){\n    int n = costs.size();\n    vector<vector<int>> dp(n+2 ,vector<int>(n+2, 0));\n\n    // main logic (always loop in oppposite fashion as compared to recursion as bottom up)\n    for(int i = n ; i >= 1 ; i--){\n        for(int j = 1 ; j <= n ; j++){\n            if(i > j){continue;}\n            int maxi = -1e9;\n\n            for(int idx = i ; idx <= j ; idx++){\n                int cost = (costs[i-1] * costs[idx] * costs[j+1]) + dp[i][idx-1] + dp[idx+1][j];\n                maxi = max(maxi, cost);\n            }\n            dp[i][j] = maxi;\n        }\n    }\n    return dp[1][n];\n}", "main_function": "int main(){\n    int n;\n    cout << \"Enter number of elements: \";\n    cin >> n;\n\n    vector<int> arr(n);\n\n    cout << \"Enter the ballons :\" << endl;\n    for(int i = 0 ; i < n ; i++){\n        cout << \"B\" << i + 1 << \" : \";\n        cin >> arr[i];\n    }\n\n    arr.push_back(1);\n    arr.insert(arr.begin(), 1); \n\n    cout << \"Max coins obtained : \" << hyper_optimized_approach(arr) << endl;\n    return 0;\n}"}
{"problem_name": "Buy Sell Cooldown", "prompt": "No prompt provided.", "space_optimal_solution": "int hyper_optimized_approach(const vector<int> &prices){    // convert s1 -> s2 \n    int n = prices.size();\n    vector<vector<int>> dp(n+2, vector<int>(2, 0));\n\n    // analogous to recursion base cases (idx == n)\n    dp[n][0] = dp[n][1] = 0;\n    for(int idx = n-1 ; idx >= 0 ; idx--){\n        // buy(1) or not buy(0)\n        dp[idx][1] = max(-prices[idx] + dp[idx+1][0], 0 + dp[idx+1][1]);\n        dp[idx][0] = max(prices[idx] + dp[idx+2][1], 0 + dp[idx+1][0]);\n    }\n    return dp[0][1];\n}", "main_function": "int main(){\n    int n;\n    cout << \"Enter number of days : \";\n    cin >> n; \n\n    vector<int> stocks(n);\n    for(int i = 0 ; i < n ; i++){\n        cout << \"Enter stock price on day \" << i+1 << \" : \";\n        cin >> stocks[i];\n    }\n\n    cout << \"[ \";\n    for(int i = 0 ; i < n ; i++){\n        cout << stocks[i] << \" \";\n    }cout << \"]\";    \n\n    cout << \"\\nMax attainable profit : \" << hyper_optimized_approach(stocks) << endl;\n}"}
{"problem_name": "Buy Sell Fee", "prompt": "No prompt provided.", "space_optimal_solution": "int hyper_optimized_approach(const vector<int> &prices, int fee){    // convert s1 -> s2 \n    int n = prices.size();\n    vector<vector<int>> dp(n+2, vector<int>(2, 0));\n\n    // analogous to recursion base cases (idx == n)\n    dp[n][0] = dp[n][1] = 0;\n    for(int idx = n-1 ; idx >= 0 ; idx--){\n        // buy(1) or not buy(0)\n        dp[idx][1] = max(-prices[idx] + dp[idx+1][0], 0 + dp[idx+1][1]);\n        dp[idx][0] = max((prices[idx] - fee) + dp[idx+2][1], 0 + dp[idx+1][0]);\n    }\n    return dp[0][1];\n}", "main_function": "int main(){\n    int n, trans_fee;\n    cout << \"Enter number of days : \";\n    cin >> n; \n\n    cout << \"Enter the fee on each transaction : \";\n    cin >> trans_fee;\n\n    vector<int> stocks(n);\n    for(int i = 0 ; i < n ; i++){\n        cout << \"Enter stock price on day \" << i+1 << \" : \";\n        cin >> stocks[i];\n    }\n\n    cout << \"[ \";\n    for(int i = 0 ; i < n ; i++){\n        cout << stocks[i] << \" \";\n    }cout << \"]\";    \n\n    cout << \"\\nMax attainable profit : \" << hyper_optimized_approach(stocks, trans_fee) << endl;\n}"}
{"problem_name": "Buy Sell Stock 1", "prompt": "No prompt provided.", "space_optimal_solution": "int hyper_optimized_approach(const vector<int> &prices){    // convert s1 -> s2 \n    int maxProfit = 0;\n    int mini = prices[0];\n\n    for(int i = 0 ; i < prices.size() ; i++){\n        int current_profit = (prices[i] - mini);\n        maxProfit = max(current_profit, maxProfit);\n        mini = min(prices[i], mini);\n    }\n    return maxProfit;\n}", "main_function": "int main(){\n    int n;\n    cout << \"Enter number of days : \";\n    cin >> n; \n\n    vector<int> stocks(n);\n    for(int i = 0 ; i < n ; i++){\n        cout << \"Enter stock price on day \" << i+1 << \" : \";\n        cin >> stocks[i];\n    }\n\n    cout << \"[ \";\n    for(int i = 0 ; i < n ; i++){\n        cout << stocks[i] << \" \";\n    }cout << \"]\";    \n\n    cout << \"\\nMax attainable profit : \" << hyper_optimized_approach(stocks) << endl;\n}"}
{"problem_name": "Buy Sell Stock 2", "prompt": "No prompt provided.", "space_optimal_solution": "int hyper_optimized_approach(const vector<int> &prices){    // convert s1 -> s2 \n    int n = prices.size();\n    vector<int> ahead(2, 0), curr(2, 0); // since for computing current state (idx) we only ahead values (idx+1) (refer tabulation logic)\n\n    ahead[0] = ahead[1] = 0;\n    for(int idx = n-1 ; idx >= 0 ; idx--){\n        for(int buy = 0 ; buy <= 1 ; buy++){    // buy(1) or not buy(0)\n            if(buy){\n                curr[buy] = max(-prices[idx] + ahead[0], 0 + ahead[1]);\n            }else{\n                curr[buy] = max(prices[idx] + ahead[1], 0 + ahead[0]);\n            }\n        }\n        ahead = curr;\n    }\n    return ahead[1];\n}", "main_function": "int main(){\n    int n;\n    cout << \"Enter number of days : \";\n    cin >> n; \n\n    vector<int> stocks(n);\n    for(int i = 0 ; i < n ; i++){\n        cout << \"Enter stock price on day \" << i+1 << \" : \";\n        cin >> stocks[i];\n    }\n\n    cout << \"[ \";\n    for(int i = 0 ; i < n ; i++){\n        cout << stocks[i] << \" \";\n    }cout << \"]\";    \n\n    cout << \"\\nMax attainable profit : \" << hyper_optimized_approach(stocks) << endl;\n}"}
{"problem_name": "Buy Sell Stock 3", "prompt": "No prompt provided.", "space_optimal_solution": "int hyper_optimized_approach(const vector<int> &prices, int capacity){    // convert s1 -> s2 \n    int n = prices.size();\n    int buy_options = 2;      \n\n    vector<vector<int>> after(buy_options, vector<int>(3, 0));\n    vector<vector<int>> curr(buy_options, vector<int>(3, 0));\n\n    // core logic\n    for(int idx = n-1 ; idx >= 0 ; idx--){\n        for(int buy = 0 ; buy < buy_options ; buy++){\n            for(int cap = 1 ; cap <= capacity ; cap++){\n                if(buy){\n                    int ahead_sell = after[0][cap];   // if decided to buy\n                    int ahead_buy = after[1][cap];    // if decided to not buy (and look ahead)\n                    curr[buy][cap] = max(-prices[idx] + ahead_sell, 0 + ahead_buy);\n                }else{\n                    int ahead_can_buy = after[1][cap-1];\n                    int ahead_must_sell = after[0][cap]; \n                    curr[buy][cap] = max(prices[idx] + ahead_can_buy, 0 + ahead_must_sell);\n                }\n            }\n        }\n        after = curr;\n    }\n    return after[1][2];\n}", "main_function": "int main(){\n    int n;\n    cout << \"Enter number of days : \";\n    cin >> n; \n\n    int transaction_cap = 2; \n\n    vector<int> stocks(n);\n    for(int i = 0 ; i < n ; i++){\n        cout << \"Enter stock price on day \" << i+1 << \" : \";\n        cin >> stocks[i];\n    }\n\n    cout << \"[ \";\n    for(int i = 0 ; i < n ; i++){\n        cout << stocks[i] << \" \";\n    }cout << \"]\";    \n\n    cout << \"\\nMax attainable profit : \" << hyper_optimized_approach(stocks, transaction_cap) << endl;\n}"}
{"problem_name": "Buy Sell Stock 4", "prompt": "No prompt provided.", "space_optimal_solution": "int hyper_optimized_approach(const vector<int> &prices, int k){    // convert s1 -> s2 \n    int n = prices.size();      \n    vector<int> after(2*k + 1, 0);\n    vector<int> curr(2*k + 1, 0);\n\n    // core logic\n    for(int idx = n-1 ; idx >= 0 ; idx--){\n        for(int tran_No = 2*k-1 ; tran_No >= 0 ; tran_No--){\n            if((tran_No % 2) == 0){\n                curr[tran_No] = max(-prices[idx] + after[tran_No+1], \n                                    0 + after[tran_No]);\n            }else{\n                curr[tran_No] = max(prices[idx] + after[tran_No+1], \n                                    0 + after[tran_No]);\n            }\n        }\n        after = curr;\n    }\n    return after[0];\n}", "main_function": "int main(){\n    int n;\n    cout << \"Enter number of days : \";\n    cin >> n; \n\n    int transaction_cap;\n    cout << \"Enter max no of transactions allowed : \";\n    cin >> transaction_cap;\n\n    vector<int> stocks(n);\n    for(int i = 0 ; i < n ; i++){\n        cout << \"Enter stock price on day \" << i+1 << \" : \";\n        cin >> stocks[i];\n    }\n\n    cout << \"[ \";\n    for(int i = 0 ; i < n ; i++){\n        cout << stocks[i] << \" \";\n    }cout << \"]\";    \n\n    cout << \"\\nMax attainable profit : \" << hyper_optimized_approach(stocks, transaction_cap) << endl;\n}"}
{"problem_name": "Coin Change Min Coins", "prompt": "You are given an array of coin denominations and a target amount. Develop a space-optimized dynamic programming algorithm to determine the minimum number of coins required to make up that amount. If it is not possible to form the amount, return -1.", "space_optimal_solution": "int hyper_optimized_approach(int n, int amount, vector<int>& coins) {\n    vector<int> prev(amount + 1, 1e9);\n\n    // Base case: 0 coins are needed for amount 0.\n    prev[0] = 0;\n    \n    // Initialize for the first coin.\n    for(int T=0; T<=amount; T++){\n        if(T % coins[0] == 0)\n            prev[T] = T / coins[0];\n    }\n\n    // Iterate through the rest of the coins.\n    for (int idx = 1; idx < n; idx++) {\n        // Iterate through all amounts.\n        for (int T = 0; T <= amount; T++) {\n            int notTake = prev[T];\n            int take = 1e9;\n            if (coins[idx] <= T) {\n                take = 1 + prev[T - coins[idx]];\n            }\n            prev[T] = min(take, notTake);\n        }\n    }\n    \n    int result = prev[amount];\n    return (result >= 1e9) ? -1 : result; // Return -1 if not possible.\n}", "main_function": "int main() {\n    vector<int> coins = {1, 2, 5};\n    int amount = 11;\n    int n = coins.size();\n\n    int result_naive = recursion_approach(n - 1, amount, coins);\n    cout << \"Minimum coins needed (Naive): \" \n         << (result_naive >= 1e9 ? -1 : result_naive) << endl;\n\n    cout << \"Minimum coins needed (Optimized): \" \n         << hyper_optimized_approach(n, amount, coins) << endl;\n\n    return 0;\n}"}
{"problem_name": "Count Subsets With Given Sum", "prompt": "You are given an array of integers and a target sum. Construct a space-optimized dynamic programming solution that counts the total number of subsets within the array that sum exactly to the given target value.", "space_optimal_solution": "int hyper_optimized_approach(int n, int k, vector<int>& arr) {\n    // prev[i] will store the count of subsets with sum 'i'.\n    vector<int> prev(k + 1, 0);\n\n    // Base case for the first element\n    if(arr[0] == 0) prev[0] = 2; // Two choices for 0: pick or not pick\n    else prev[0] = 1; // Only one choice for non-zero: not pick\n    \n    if(arr[0] != 0 && arr[0] <= k) prev[arr[0]] = 1;\n\n\n    // Iterate through the rest of the array elements.\n    for (int idx = 1; idx < n; idx++) {\n        // Iterate backwards from the target sum.\n        for (int target = k; target >= 0; target--) {\n            int not_take = prev[target];\n            int take = 0;\n            if(arr[idx] <= target) take = prev[target - arr[idx]];\n            \n            prev[target] = take + not_take;\n        }\n    }\n    \n    // The final answer is the number of ways to form the target sum 'k'.\n    return prev[k];\n}", "main_function": "int main() {\n    vector<int> arr = {1, 2, 3, 3};\n    int target = 6;\n    int n = arr.size();\n\n    cout << \"Number of subsets with sum \" << target << \" (Optimized): \" \n         << hyper_optimized_approach(n, target, arr) << endl;\n    return 0;\n}"}
{"problem_name": "Distinct Subseq", "prompt": "No prompt provided.", "space_optimal_solution": "int hyper_optimized_approach(string &s1, string &s2){    // convert s1 -> s2 \n    int n = s1.size();\n    int m = s2.size();\n    vector<int> prev(m + 1, 0);\n\n    // dp logic -> 1-D array logic\n    prev[0] = 1;\n\n    for(int i = 0 ; i <= n ; i++){\n        for(int j = m ; j >= 1 ; j--){\n            if(s1[i-1] == s2[j-1]){\n                prev[j] = prev[j-1] + prev[j];\n            }else{\n                continue;    // no change (same value remains)\n            }\n        }\n    }return prev[m];\n}", "main_function": "int main(){\n    string s1, s2;      // count occurences of s2 in s1\n    cout << \"Source string : \";\n    cin >> s1;\n\n    cout << \"Target string : \";\n    cin >> s2;\n\n    // vector<vector<int>> dp(s1.size(), vector<int>(s2.size(), -1));\n\n    cout << \"\\nOccurences : \" << hyper_optimized_approach(s1, s2) << endl;\n    return 0;\n}"}
{"problem_name": "Edit Distance", "prompt": "No prompt provided.", "space_optimal_solution": "int hyper_optimized_approach(string &s1, string &s2){    // convert s1 -> s2 \n    int n = s1.size();\n    int m = s2.size();\n    vector<int> prev(m+1, 0), curr(m+1, 0);\n\n    // initial fillings (analogous to tabulation case)\n    for(int j = 0 ; j <= m ; j++){\n        prev[j] = j;\n    }\n    for(int i = 1 ; i <= n ; i++){\n        curr[0] = i;\n        for(int j = 1 ; j <= m ; j++){\n            if(s1[i-1] == s2[j-1]){\n                curr[j] = prev[j-1];\n            }else{\n                curr[j] = 1 + min(curr[j-1], min(prev[j], prev[j-1]));\n            }\n        }\n        prev = curr;\n    }\n    return prev[m];\n}", "main_function": "int main(){\n    string s1, s2;     \n    cout << \"Source string : \";\n    cin >> s1;\n\n    cout << \"Target string : \";\n    cin >> s2;\n\n    cout << \"Allowed operations (Insert, Delete, Replace)\" << endl;\n    // vector<vector<int>> dp(s1.size(), vector<int>(s2.size(), -1));\n\n    cout << \"\\nMin operations needed : \" << hyper_optimized_approach(s1, s2) << endl;\n    return 0;\n}"}
{"problem_name": "Largest Div Subset", "prompt": "No prompt provided.", "space_optimal_solution": "int hyper_optimized_approach(vector<int> &arr){\n    int n = arr.size();\n    vector<int> dp(n, 1);\n    int maxi = 1;\n    \n    sort(arr.begin(), arr.end());\n    // main logic (hash array to help in printing LIS sequence)\n    for(int cur = 0 ; cur < n ; cur++){\n        for(int prev = 0 ; prev < cur ; prev++){\n            if(arr[cur] % arr[prev] == 0 && 1 + dp[prev] > dp[cur]){   // valid increasing\n                dp[cur] = 1 + dp[prev];\n            }\n        }\n        maxi = max(maxi, dp[cur]);\n    }\n    return maxi;\n}", "main_function": "int main(){\n    int n;\n    cout << \"Enter number of elements: \";\n    cin >> n;\n    vector<int> arr(n);\n\n    for(int i = 0 ; i < n ; i++){\n        cout << \"Element \" << i + 1 << \" : \";\n        cin >> arr[i];\n    }\n\n    printArray(arr);\n    vector<vector<int>> dp(n, vector<int>(n + 1, -1));\n\n    cout << \"Length of LIS : \" << hyper_optimized_approach(arr) << endl;\n    return 0;\n}"}
{"problem_name": "Lbs", "prompt": "No prompt provided.", "space_optimal_solution": "int hyper_optimized_approach(const vector<int> &arr){\n    int n = arr.size();\n    vector<int> dp_f(n, 1);\n    \n    // main logic (figuring out LIS from front traversal)\n    for(int cur = 0 ; cur < n ; cur++){\n        for(int prev = 0 ; prev < cur ; prev++){\n            if(arr[cur] > arr[prev] && 1 + dp_f[prev] > dp_f[cur]){   // valid increasing\n                dp_f[cur] = 1 + dp_f[prev];\n            }\n        }\n    }\n\n    vector<int> dp_b(n, 1);\n    // main logic (figuring out LIS from rear traversal)\n    for(int cur = n-1 ; cur >= 0 ; cur--){\n        for(int prev = n-1 ; prev > cur ; prev--){\n            if(arr[cur] > arr[prev] && 1 + dp_b[prev] > dp_b[cur]){   // valid increasing\n                dp_b[cur] = 1 + dp_b[prev];\n            }\n        }\n    }\n\n    vector<int> bitonic(n, 0);\n    int maxi = 1;\n    for(int i = 0 ; i < n ; i++){\n        bitonic[i] = (dp_f[i] + dp_b[i] - 1);   // -1 to avoid double counting of peak element\n        maxi = max(maxi, bitonic[i]);\n    }\n    return maxi;\n}", "main_function": "int main(){\n    int n;\n    cout << \"Enter number of elements: \";\n    cin >> n;\n    vector<int> arr(n);\n\n    for(int i = 0 ; i < n ; i++){\n        cout << \"Element \" << i + 1 << \" : \";\n        cin >> arr[i];\n    }\n\n    cout << \"Length of LIS : \" << hyper_optimized_approach(arr) << endl;\n    return 0;\n}"}
{"problem_name": "Lcs", "prompt": "No prompt provided.", "space_optimal_solution": "int hyper_optimized_approach(string &s1, string &s2){\n    int n = s1.size();\n    int m = s2.size();\n    vector<int> prev(m + 1, 0), curr(m + 1, 0);\n\n    // base cases\n    for(int j = 0 ; j <= m ; j++){\n        prev[j] = 0;\n    }\n    \n    for(int i = 1 ; i <= n ; i++){\n        for(int j = 1 ; j <= m ; j++){\n            if(s1[i-1] == s2[j-1]){\n                curr[j] = 1 + prev[j-1];\n            }else{\n                curr[j] = 0 + max(prev[j], curr[j-1]);\n            }\n        }\n        prev = curr;\n    }\n    return prev[m];\n}", "main_function": "int main(){\n    string s1, s2;\n    cout << \"Enter first string: \";\n    cin >> s1;\n    cout << \"Enter second string: \";\n    cin >> s2;\n\n    cout << \"Length of LCS between \" << s1 << \" and \" << s2 << \" is: \" << hyper_optimized_approach(s1, s2) << endl;\n    return 0;\n}"}
{"problem_name": "Lis", "prompt": "No prompt provided.", "space_optimal_solution": "int hyper_optimized_approach(const vector<int> &arr){\n    int n = arr.size();\n    vector<int> dp(n, 1);\n    int maxi = 1;\n    \n    // main logic (hash array to help in printing LIS sequence)\n    for(int cur = 0 ; cur < n ; cur++){\n        for(int prev = 0 ; prev < cur ; prev++){\n            if(arr[cur] > arr[prev] && 1 + dp[prev] > dp[cur]){   // valid increasing\n                dp[cur] = 1 + dp[prev];\n            }\n        }\n        maxi = max(maxi, dp[cur]);\n    }\n    return maxi;\n}", "main_function": "int main(){\n    int n;\n    cout << \"Enter number of elements: \";\n    cin >> n;\n    vector<int> arr(n);\n\n    for(int i = 0 ; i < n ; i++){\n        cout << \"Element \" << i + 1 << \" : \";\n        cin >> arr[i];\n    }\n\n    vector<vector<int>> dp(n, vector<int>(n + 1, -1));\n\n    cout << \"Length of LIS : \" << hyper_optimized_approach(arr) << endl;\n    return 0;\n}"}
{"problem_name": "Lis Binary Search", "prompt": "No prompt provided.", "space_optimal_solution": "(using Binary Search concept)\n\nint hyper_optimized_approach(const vector<int> &arr){\n    vector<int> temp;\n    temp.push_back(arr[0]);\n    int len = 1;\n    int n = arr.size();\n\n    for(int i = 1 ; i < n ; i++){\n        if(arr[i] > temp.back()){\n            temp.push_back(arr[i]);\n            len++;\n        }\n        else{\n            // find the index of the smallest number >= arr[i]\n            int ind = lower_bound(temp.begin(), temp.end(), arr[i]) - temp.begin();\n            temp[ind] = arr[i];   // replace that number with arr[i]\n        }\n    }\n    return len;               // length of LIS is size of temp vector\n}", "main_function": "int main(){\n    int n;\n    cout << \"Enter number of elements: \";\n    cin >> n;\n    vector<int> arr(n);\n\n    for(int i = 0 ; i < n ; i++){\n        cout << \"Element \" << i + 1 << \" : \";\n        cin >> arr[i];\n    }\n\n    vector<vector<int>> dp(n, vector<int>(n + 1, -1));\n\n    cout << \"Length of LIS : \" << hyper_optimized_approach(arr) << endl;\n    return 0;\n}"}
{"problem_name": "Longest Palindromic Subsequence", "prompt": "No prompt provided.", "space_optimal_solution": "int hyper_optimized_approach(string &s1){\n    string s2 = s1;\n    reverse(s2.begin(), s2.end());\n    // int n = s1.size();\n    // int m = s2.size();\n    vector<int> prev(s2.size() + 1, 0), curr(s2.size() + 1, 0);\n\n    // base cases\n    for(int j = 0 ; j <= s2.size() ; j++){\n        prev[j] = 0;\n    }\n    \n    for(int i = 1 ; i <= s1.size() ; i++){\n        for(int j = 1 ; j <= s2.size() ; j++){\n            if(s1[i-1] == s2[j-1]){\n                curr[j] = 1 + prev[j-1];\n            }else{\n                curr[j] = 0 + max(prev[j], curr[j-1]);\n            }\n        }\n        prev = curr;\n    }\n    return prev[s2.size()];\n}", "main_function": "int main(){\n    string s1;\n    cout << \"Enter a string: \";\n    cin >> s1;\n\n    cout << s1;\n    cout << \"\\nLongest palindromic subsequence :\" << hyper_optimized_approach(s1) << endl;\n    return 0;\n}"}
{"problem_name": "Lsc", "prompt": "No prompt provided.", "space_optimal_solution": "int hyper_optimized_approach(vector<string> &arr){\n    int n = arr.size();\n    vector<int> dp(n, 1);\n    int maxi = 1;\n    \n    // main logic (hash array to help in printing LIS sequence)\n    sort(arr.begin(), arr.end(), comp);     // as sequence can start from any element (progressing by 1 character) and not just in chronological order\n\n    for(int cur = 0 ; cur < n ; cur++){\n        for(int prev = 0 ; prev < cur ; prev++){\n            if(checkPossible(arr[cur], arr[prev])){   // valid increasing\n                if(1 + dp[prev] > dp[cur]){\n                    dp[cur] = 1 + dp[prev];\n                }\n            }\n        }\n        maxi = max(maxi, dp[cur]);\n    }\n    return maxi;\n}", "main_function": "int main(){\n    int n;\n    cout << \"Enter vector size: \";\n    cin >> n;\n    vector<string> arr(n);\n\n    for(int i = 0 ; i < n ; i++){\n        cout << \"Element \" << i + 1 << \" : \";\n        cin >> arr[i];\n    }\n\n    cout << \"Length of LSC  : \" << hyper_optimized_approach(arr) << endl;\n    return 0;\n}"}
{"problem_name": "Mcm", "prompt": "No prompt provided.", "space_optimal_solution": "// (BOTTOM-UP approach) (TC : O(n^3), SC : O(n^2))\nint hyper_optimized_approach(const vector<int> &arr, int size){\n    int n = arr.size();\n    vector<vector<int>> dp(n ,vector<int>(n, 0));\n\n    // main logic\n    for(int i = 0 ; i < n ; i++){\n        dp[i][i] = 0;                   // analogous to rec base cases\n    }\n    for(int i = n-1 ; i >= 1 ; i--){\n        for(int j = i+1 ; j < n ; j++){\n            int mini = 1e9;\n            for(int k = i ; k <= j-1 ; k++){\n                int steps = (arr[i-1] * arr[k] * arr[j]) + dp[i][k] + dp[k+1][j];\n                mini = min(mini, steps);\n            }\n            dp[i][j] = mini;\n        }\n    }\n    return dp[1][n-1];\n}", "main_function": "int main(){\n    int n;\n    cout << \"Enter number of elements: \";\n    cin >> n;\n    vector<int> arr(n);\n\n    cout << \"Enter the MCM dimension vector :\" << endl;\n    for(int i = 0 ; i < n ; i++){\n        cout << \"Dimension \" << i + 1 << \" : \";\n        cin >> arr[i];\n    }\n\n    cout << \"Min number of operations : \" << hyper_optimized_approach(arr, n) << endl;\n    return 0;\n}"}
{"problem_name": "Min Cost Cut Stick", "prompt": "No prompt provided.", "space_optimal_solution": "// (BOTTOM-UP approach) (TC : O(n^3), SC : O(n^2))\nint hyper_optimized_approach(const vector<int> &cuts){\n    int n = cuts.size();\n    vector<vector<int>> dp(n+2 ,vector<int>(n+2, 0));\n\n    // main logic (always loop in oppposite fashion as compared to recursion as bottom up)\n    for(int i = n ; i >= 1 ; i--){\n        for(int j = 1 ; j <= n ; j++){\n            if(i > j){continue;}\n            int mini = 1e9;\n\n            for(int idx = i ; idx<= j ; idx++){\n                int cost = (cuts[j+1] - cuts[i-1]) + dp[i][idx-1] + dp[idx+1][j];\n                dp[i][j] = min(mini, cost);\n            }\n            dp[i][j] = mini;\n        }\n    }\n    return dp[1][n];\n}", "main_function": "int main(){\n    int n, l;\n    cout << \"Enter number of elements: \";\n    cin >> n;\n    cout << \"Enter length of the stick: \";\n    cin >> l;\n    vector<int> arr(n);\n\n    cout << \"Enter the cutting positions :\" << endl;\n    for(int i = 0 ; i < n ; i++){\n        cout << \"Pos \" << i + 1 << \" : \";\n        cin >> arr[i];\n    }\n\n    // adding the two ends of the stick to the cuts array\n    arr.push_back(l);\n    arr.insert(arr.begin(), 0); // adding the two ends of the stick\n    sort(arr.begin(), arr.end());\n    \n\n    cout << \"Min cost to cut the stick : \" << hyper_optimized_approach(arr) << endl;\n    return 0;\n}"}
{"problem_name": "Min Insertions Palindrome", "prompt": "No prompt provided.", "space_optimal_solution": "int hyper_optimized_approach(string &s1){\n    string s2 = s1;\n    reverse(s2.begin(), s2.end());\n\n    int n = s1.size();\n    int m = s2.size();\n    vector<int> prev(m + 1, 0), curr(m + 1, 0);\n\n    // base cases\n    for(int j = 0 ; j <= m ; j++){\n        prev[j] = 0;\n    }\n    \n    for(int i = 1 ; i <= n ; i++){\n        for(int j = 1 ; j <= m ; j++){\n            if(s1[i-1] == s2[j-1]){\n                curr[j] = 1 + prev[i-1];\n            }else{\n                curr[j] = 0 + max(prev[j], curr[j-1]);\n            }\n        }\n        prev = curr;\n    }\n    int length_lps = prev[m];\n    int min_insertions_to_make_palindrome = (s1.size() - length_lps);\n    return min_insertions_to_make_palindrome;\n}", "main_function": "int main(){\n    string s1;\n    cout << \"Enter a string: \";\n    cin >> s1;\n\n    cout << s1;\n    // cout << \"\\nLongest palindromic subsequence :\" << LPS(s1) << endl;\n    cout << \"\\nMinimum insertions needed : \" << hyper_optimized_approach(s1) << endl;\n    return 0;\n}"}
{"problem_name": "Min Operations Transform String", "prompt": "No prompt provided.", "space_optimal_solution": "int hyper_optimized_approach(string &s1, string &s2, int n, int m){    // convert s1 -> s2 \n    vector<int> prev(m + 1, 0), curr(m + 1, 0);\n\n    // base cases\n    for(int j = 0 ; j <= m ; j++){\n        prev[j] = 0;\n    }\n    \n    for(int i = 1 ; i <= n ; i++){\n        for(int j = 1 ; j <= m ; j++){\n            if(s1[i-1] == s2[j-1]){\n                curr[j] = 1 + prev[j-1];\n            }else{\n                curr[j] = 0 + max(prev[j], curr[j-1]);\n            }\n        }\n        prev = curr;\n    }\n    // abcd(s1) --> anc(s2) \n    // No of deletions = 2 (b, d) [len(abcd) - len(lcs(s1))(=ac)]\n    // No of insertions = 1(n) [len(anc) - len(lcs(s1))(=ac)]\n    int total_min_operations = (s1.size() - prev[m]) + (s2.size() - prev[m]);      // len of lcs stored at prev[m](last idx)\n    return total_min_operations;\n}", "main_function": "int main(){\n    string s1, s2;\n    cout << \"Source string : \";\n    cin >> s1;\n\n    cout << \"Target string : \";\n    cin >> s2;\n\n    int n = s1.size();\n    int m = s2.size();\n    cout << \"\\n\" << s1 << \" ----> \" << s2 << \"(\" << hyper_optimized_approach(s1, s2, n, m) << \" operations)\"<< endl;\n    return 0;\n}"}
{"problem_name": "Min Subset Sum Diff", "prompt": "You are given an array of positive integers. Write a space-optimized dynamic programming solution to find the minimum possible absolute difference between the sums of two subsets formed from this array.", "space_optimal_solution": "int hyper_optimized_approach(int n, vector<int>& arr) {\n    int total_sum = 0;\n    for (int x : arr) {\n        total_sum += x;\n    }\n\n    int k = total_sum;\n    vector<bool> prev(k + 1, false);\n    prev[0] = true;\n\n    if (arr[0] <= k) {\n        prev[arr[0]] = true;\n    }\n\n    for (int idx = 1; idx < n; idx++) {\n        for (int target = k; target >= arr[idx]; target--) {\n            prev[target] = prev[target] || prev[target - arr[idx]];\n        }\n    }\n\n    int min_diff = 1e9;\n    // The possible sums for one subset are marked as 'true' in the prev array.\n    // We only need to check up to total_sum/2.\n    for (int s1 = 0; s1 <= total_sum / 2; s1++) {\n        if (prev[s1]) {\n            // s2 = total_sum - s1\n            // diff = abs(s2 - s1) = abs(total_sum - 2*s1)\n            min_diff = min(min_diff, abs(total_sum - 2 * s1));\n        }\n    }\n    return min_diff;\n}", "main_function": "int main() {\n    vector<int> arr = {1, 6, 11, 5};\n    int n = arr.size();\n    \n    cout << \"Minimum subset sum difference (Optimized): \" << hyper_optimized_approach(n, arr) << endl;\n\n    return 0;\n}"}
{"problem_name": "N Lis", "prompt": "No prompt provided.", "space_optimal_solution": "int hyper_optimized_approach(const vector<int> &arr){\n    int n = arr.size();\n    vector<int> dp(n, 1);\n    vector<int> count(n, 1);\n    int maxi = 1;\n    \n    // main logic (hash array to help in printing LIS sequence)\n    for(int cur = 0 ; cur < n ; cur++){\n        for(int prev = 0 ; prev < cur ; prev++){\n            if(arr[cur] > arr[prev] && 1 + dp[prev] > dp[cur]){   // valid increasing\n                dp[cur] = 1 + dp[prev];\n                count[cur] = count[prev];               // inherit count\n            }else if(arr[cur] > arr[prev] && 1 + dp[prev] == dp[cur]){   //(when duplicate value of LIS length found in dp)\n                count[cur] += count[prev];              // add count\n            }\n        }\n        maxi = max(maxi, dp[cur]);\n    }\n    int totalCount = 0;\n    for(int i = 0 ; i < n ; i++){\n        if(dp[i] == maxi){\n            totalCount += count[i];\n        }\n    }\n    return totalCount;\n}", "main_function": "int main(){\n    int n;\n    cout << \"Enter number of elements: \";\n    cin >> n;\n    vector<int> arr(n);\n\n    for(int i = 0 ; i < n ; i++){\n        cout << \"Element \" << i + 1 << \" : \";\n        cin >> arr[i];\n    }\n\n    cout << \"Number of distinct LIS's possible : \" << hyper_optimized_approach(arr) << endl;\n    return 0;\n}"}
{"problem_name": "Palindrome Partitioning", "prompt": "No prompt provided.", "space_optimal_solution": "// (BOTTOM-UP approach) (TC : O(n^2 * m), SC : O(n))\nint hyper_optimized_approach(const string &s){\n    int n = s.size();\n    vector<int> dp(n+1, 0);\n\n    dp[n] = 0;  // base case\n\n    for(int i = n-1 ; i >= 0 ; i--){\n        string temp = \"\";\n        int minCost = 1e9;\n        for(int j = i ; j < n ; j++){\n            temp += s[j];\n            if(isPalidrome(temp)){\n                int cost = 1 + dp[j+1];\n                minCost = min(minCost, cost);\n            }\n        }\n        dp[i] = minCost;\n    }\n    return dp[0];\n}", "main_function": "int main(){\n    string s;\n    cout << \"Enter string: \";\n    cin >> s;\n\n    cout << \"String : \" << s << endl;\n\n    cout << \"Min partition cost : \" << hyper_optimized_approach(s) - 1 << endl;\n    return 0;\n}"}
{"problem_name": "Partition Equal Subsets", "prompt": "You are given an array of positive integers. Implement a space-optimized dynamic programming approach to determine whether the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.", "space_optimal_solution": "bool hyper_optimized_approach(int n, vector<int> &arr) {\n    int total_sum = 0;\n    for (int x : arr) {\n        total_sum += x;\n    }\n    // If total sum is odd, it cannot be partitioned into two equal halves.\n    if (total_sum % 2 != 0) {\n        return false;\n    }\n    int k = total_sum / 2;\n    vector<bool> prev(k + 1, false);\n    prev[0] = true;\n    if (arr[0] <= k) {\n        prev[arr[0]] = true;\n    }\n\n    for (int idx = 1; idx < n; idx++) {\n        for (int target = k; target >= arr[idx]; target--) {\n            prev[target] = prev[target] || prev[target - arr[idx]];\n        }\n    }\n    return prev[k];\n}", "main_function": "int main() {\n    vector<int> arr = {10, 20, 15, 5, 25, 30};\n    int n = arr.size();\n    \n    cout << hyper_optimized_approach(n, arr);\n\n    return 0;\n}"}
{"problem_name": "Partition Max Sum", "prompt": "No prompt provided.", "space_optimal_solution": "// (BOTTOM-UP approach) (TC : O(n*k), SC : O(n))\nint hyper_optimized_approach(int k, const vector<int> &arr){\n    int n = arr.size();\n    vector<int> dp(n + 1, 0);  // dp[i] -> max sum for subarray arr[0...i-1]\n\n    dp[n] = 0; // base case\n\n    for(int i = n-1 ; i >= 0 ; i--){\n        int maxAns = INT_MIN;\n        int maxi = INT_MIN;\n        int len = 0;\n        for(int j = i ; j < (i + k) && j < n ; j++){\n            len++;\n            maxi = max(maxi, arr[j]);\n            int sum = (maxi * len) + dp[j + 1]; // dp[j + 1] -> max sum for subarray arr[0...j]\n            maxAns = max(maxAns, sum);\n        }\n        dp[i] = maxAns;\n    }\n    return dp[0];\n}", "main_function": "int main(){\n    int n, k;\n    cout << \"Enter number of elements : \";\n    cin >> n;\n    cout << \"Enter max partition size : \";\n    cin >> k;\n\n    vector<int> arr(n);\n    cout << \"Enter elements : \";\n    for(int i = 0 ; i < n ; i++){\n        cin >> arr[i];\n    }\n\n    cout << \"Max sum : \" << hyper_optimized_approach(k, arr) << endl;\n    return 0;\n}"}
{"problem_name": "Rod Cutting", "prompt": "You are given a rod of length n and an array where each element represents the price of a rod piece of that length (from 1 to n). Formulate a space-optimized dynamic programming solution to determine the maximum profit obtainable by cutting the rod into smaller pieces and selling them. You can make unlimited cuts of any available length.", "space_optimal_solution": "int hyper_optimized_approach(int n, vector<int>& prices) {\n    vector<int> prev(n + 1, 0);\n\n    // Base case: maximum price for a rod of length 'i' using only pieces of length 1.\n    for (int i = 0; i <= n; i++) {\n        prev[i] = i * prices[0];\n    }\n\n    // Iterate through all possible piece lengths (2 to n).\n    for (int idx = 1; idx < n; idx++) {\n        // Iterate through all possible rod lengths.\n        for (int N = 0; N <= n; N++) {\n            int notTake = prev[N];\n            int take = INT_MIN;\n            int rod_length = idx + 1;\n            if (rod_length <= N) {\n                take = prices[idx] + prev[N - rod_length];\n            }\n            prev[N] = max(take, notTake);\n        }\n    }\n    return prev[n];\n}", "main_function": "int main() {\n    vector<int> prices = {1, 5, 8, 9, 10, 17, 17, 20}; // prices for lengths 1 to 8\n    int n = prices.size();\n\n    cout << \"Max profit : \" << hyper_optimized_approach(n, prices) << endl;\n    return 0;\n}"}
{"problem_name": "Shortest Common Superseq", "prompt": "No prompt provided.", "space_optimal_solution": "int hyper_optimized_approach(string &s1, string &s2, int n, int m){    // convert s1 -> s2 \n    vector<int> prev(m + 1, 0), curr(m + 1, 0);\n\n    // base cases\n    for(int j = 0 ; j <= m ; j++){\n        prev[j] = 0;\n    }\n    \n    for(int i = 1 ; i <= n ; i++){\n        for(int j = 1 ; j <= m ; j++){\n            if(s1[i-1] == s2[j-1]){\n                curr[j] = 1 + prev[j-1];\n            }else{\n                curr[j] = 0 + max(prev[j], curr[j-1]);\n            }\n        }\n        prev = curr;\n    }\n    // s1 : brute, s2 : groot => len(scs) = len(s1) + len(s2) - len(lcs(s1, s2)) = 5 + 5 - 2 = 8 (bgruoote) (order maintained)\n    int length_scs = (n + m - prev[m]);    // length(lcs) stored at prev[m] \n    return length_scs;\n}", "main_function": "int main(){\n    string s1, s2;\n    cout << \"s1 : \";\n    cin >> s1;\n\n    cout << \"s2 : \";\n    cin >> s2;\n\n    int n = s1.size();\n    int m = s2.size();\n\n    cout << \"\\nLength of SCS : \" << hyper_optimized_approach(s1, s2, n, m) << endl;\n    return 0;\n}"}
{"problem_name": "Subset Sum", "prompt": "You are given an array of integers and a target value. Implement a space-optimized dynamic programming approach to determine whether there exists at least one subset of the given array whose elements sum exactly to the target value. Return true if such a subset exists, otherwise false.", "space_optimal_solution": "int hyper_optimized_approach(int n, int target, vector<int> &arr){\n    vector<bool> prev(target + 1, false);\n    \n    // base cases\n    prev[0] = true;\n    if(arr[0] <= target){\n        prev[arr[0]] = true;\n    }\n    for(int idx = 1 ; idx < n ; idx++){\n        for(int t = target ; t >= 0 ; t--){\n            prev[t] = prev[t] || (t >= arr[idx] ? prev[t - arr[idx]] : false);\n        }\n    }\n    return prev[target];\n}", "main_function": "int main() {\n    vector<int> arr = {3, 34, 4, 12, 5, 2};\n    int target = 9;\n    int n = arr.size();\n\n    cout << (hyper_optimized_approach(n, target, arr) ? \"Yes\" : \"No\") << endl;\n\n    return 0;\n}"}
{"problem_name": "Target Sum", "prompt": "You are given an array of integers and a target value. Each element can be assigned either a '+' or '-' sign. Write a space-optimized dynamic programming solution to count the total number of ways to assign these signs so that the resulting expression evaluates exactly to the target sum.", "space_optimal_solution": "int hyper_optimized_approach(int n, int target, vector<int>& nums) {\n    int total_sum = 0;\n    for(int x : nums) total_sum += x;\n\n    // Conditions for impossibility.\n    // 1. The target sum must be achievable.\n    // 2. (total_sum - target) must be non-negative and even.\n    if (total_sum - target < 0 || (total_sum - target) % 2 != 0) {\n        return 0;\n    }\n\n    // This problem reduces to finding the number of subsets with sum s2,\n    // where s2 = (total_sum - target) / 2.\n    int s2 = (total_sum - target) / 2;\n    \n    vector<int> prev(s2 + 1, 0);\n    prev[0] = 1;\n    \n    // This is now the 'Count Subsets with Sum' problem.\n    for (int i = 0; i < n; i++) {\n        for (int t = s2; t >= nums[i]; t--) {\n            prev[t] = prev[t] + prev[t - nums[i]];\n        }\n    }\n    return prev[s2];\n}", "main_function": "int main() {\n    vector<int> nums = {1, 1, 1, 1, 1};\n    int target = 3;\n    int n = nums.size();\n\n    cout << \"Number of ways to get target sum : \"  << hyper_optimized_approach(n, target, nums) << endl;\n\n    return 0;\n}"}
{"problem_name": "Unbounded Knapsack", "prompt": "You are given n items with given weights and values; find the maximum total value that can be obtained in an unbounded knapsack of capacity maxWeight using a space-optimized DP approach", "space_optimal_solution": "int hyper_optimized_approach(int n, int maxWeight, vector<int> &weights, vector<int> &values){\n    vector<int> prev(maxWeight + 1, 0);\n    for(int w = 0 ; w <= maxWeight ; w++){\n        prev[w] = (int(w / weights[0]) * values[0]);\n    }\n\n    // Iterate through the rest of the items.\n    for(int idx = 1 ; idx < n ; idx++){\n        // Iterate forwards through the weights.\n        for(int w = 0 ; w <= maxWeight ; w++){\n            int notTake = 0 + prev[w];\n            int take = 0;\n            if(weights[idx] <= w){\n                // prev[w - weights[idx]] already contains the optimized value\n                // which might include the current item.\n                take = values[idx] + prev[w - weights[idx]];\n            }\n            prev[w] = max(take, notTake);\n        }\n    }\n    return prev[maxWeight];\n}", "main_function": "int main() {\n    vector<int> weights = {5, 7, 9, 11};\n    vector<int> values  = {10, 13, 18, 20};\n    int maxWeight = 25;\n    int n = weights.size();\n\n    cout << \"Max value in Unbounded Knapsack : \" << hyper_optimized_approach(n, maxWeight, weights, values) << endl;\n\n    return 0;\n}"}
{"problem_name": "Wildcard Match", "prompt": "No prompt provided.", "space_optimal_solution": "bool hyper_optimized_approach(string &s1, string &s2){    // convert s1 -> s2 \n    int m = s2.size();\n    int n = s1.size();\n    vector<bool> prev(m+1, false), curr(m+1, false);\n\n    prev[0] = true;\n    for(int j = 1 ; j <= m ; j++){\n        prev[j] = false;\n    }\n    for(int i = 1 ; i <= n ; i++){\n        // for every row 'i' you are assiging value at [0]  (first column : [i][0])\n        bool flag = true;\n        for(int k = 0 ; k <= i ; k++){\n            if(s1[k] != '*'){\n                flag = false;\n                break;\n            }\n        }\n        curr[0] = flag;       \n\n        for(int j = 1 ; j <= m ; j++){\n            if(s1[i-1] == s2[j-1] || s1[i-1] == '?'){\n                curr[j] = prev[j-1];\n            }else if(s1[i-1] == '*'){\n                curr[j] = prev[j] || curr[j-1];\n            }else{\n                curr[j] = false;\n            }\n        }\n        prev = curr;\n    }\n    return prev[m];\n}", "main_function": "int main(){\n    string s1, s2;     \n    cout << \"Ground rules : \" << endl;\n    cout << \"? -> Matches with a single character (a-z)\" << endl;\n    cout << \"* -> Matches with a seq of length >= 0\" << endl;\n\n    cout << \"s1 : \";\n    cin >> s1;\n\n    cout << \"s2 : \";\n    cin >> s2;\n\n\n    cout << \"\\nMatching ? : \" << hyper_optimized_approach(s1, s2) << endl;\n    return 0;\n}"}
